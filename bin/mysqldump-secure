#!/bin/sh -u
#
# -u: nounset (enable: set -u | disable: set +u)
# -e: errexit
# -r: restricted
#
# Script to dump databases one by one
#
# Exit Codes
# ---------------------
# * 0: Success
# * 1: Script specific: (writeable directory, config file not found, wrong permissions)
# * 2: Required binary not found
# * 3: MySQL connection error
# * 4: MySQL Database dump error

INFO_NAME="mysqldump-secure"
INFO_AUTHOR="Patrick Plocke <patrick@plocke.de>"
INFO_GPGKEY="0x28BF179F"
INFO_LICENSE="MIT"
INFO_URL="https://github.com/cytopia/mysqldump-secure"
INFO_DATE="2016-02-27"
INFO_VERSION="0.16"


################################################################################
#
# AUTO-GENERATED
#
################################################################################

# The following are auto-generated variables by the installer.
# to determine where the script and its config files are installed.
_PREFIX_ETC=""
#_PREFIX_BIN=""
#_PREFIX_LOG=""



################################################################################
#
# DEFAULT VARIABLES
#
################################################################################

#
# Do not djust the following default variables!
# They can be overwritten inside mysqldump-secure.conf
# or via command line arguments
#

# Default Configuration Path/Name
_DEFAULT_CONFIG_FILE="${_PREFIX_ETC}/etc/mysqldump-secure.conf"
_DEFAULT_CONFIG_CHMOD="0400"

# Default output Variables
_DEFAULT_DUMP_FILE_PRE="$(date '+%Y-%m-%d')_$(date '+%H-%M')__"
_DEFAULT_DUMP_FILE_CHMOD="0400"
_DEFAULT_DUMP_DIR_CHMOD="0700"
_DEFAULT_DUMP_PATH="${_PREFIX_ETC}/var/mysqldump-secure"


# MySQL defaults
_DEFAULT_MYSQL_CNF_CHMOD="0400"
_DEFAULT_MYSQL_CNF_FILE="${_PREFIX_ETC}/etc/mysqldump-secure.cnf"


# Default OpenSSL Variables
_DEFAULT_OPENSSL_ALGO_ARG="-aes256"

# Logging defaults
_DEFAULT_LOG_CHMOD="0600"
_DEFAULT_LOGFILE="${_PREFIX_ETC}/var/log/mysqldump-secure.log"

# Default nagios variables
_DEFAULT_NAGIOS_LOG_CHMOD="0644"


# These command line arguments are considered insecure and can lead
# to compromising your data
MYSQL_EVIL_OPTS="--password -p --port -P --user -u --host -h --socket -s"

# Do not allow to read any other MySQL configuration file
# than the one specified in the configuration.
# Also all SSL Options are done via configuration
MYSQL_BAD_OPTS="--no-defaults --defaults-extra-file --defaults-file --ssl --ssl-ca --ssl-cert --ssl-key --single-transaction --lock-tables"



################################################################################
#
# T E R M I N A L   C O L O R S
#
################################################################################

if [ -t 1 ]; then
	CLR_ERROR="$(tput setf 4 2>/dev/null || tput setaf 1 2>/dev/null)"
	CLR_WARNING="$(tput setf 6 2>/dev/null || tput setaf 3 2>/dev/null)"
	CLR_DEBUG="$(tput setf 0 2>/dev/null || tput setaf 7 2>/dev/null)"
	CLR_RESET="$(tput sgr0 2>/dev/null)"
else
	CLR_ERROR=""
	CLR_WARNING=""
	CLR_DEBUG=""
	CLR_RESET=""
fi



################################################################################
#
# F U N C T I O N S
#
################################################################################

############################################################
# Output wrapper
############################################################

# Output to stdout/stderr and to file (with newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debug() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s\n" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "verbose" ] && printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${_msg}"
		fi
	fi


	# Always show warn and error
	[ "${_lvl}" = "warn" ] && printf "${CLR_WARNING}[WARN]  %s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"  ] && printf "${CLR_ERROR}[ERR]   %s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "verbose" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "
		printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
	fi
	return 0
}


# Output to stdout/stderr and to file (with multiple lines).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugr() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# [INFO]/[DEBUG] Hide info/debug output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		# [INFO]
		if [ "${_lvl}" = "info" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "[INFO]  %s\n" "${line}"
			done
			unset IFS
		fi

		# [DEBUG] Show debug output?
		if [ "${_debug}" = "1" ]; then
			if [ "${_lvl}" = "verbose" ]; then
				IFS='
				'
				for line in ${_msg}; do
					printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${line}"
				done
				unset IFS
			fi
		fi
	fi



	# [WARN] Always show warn and error
	if [ "${_lvl}" = "warn" ]; then
		IFS='
		'
		for line in ${_msg}; do
			printf "${CLR_WARNING}[WARN]  %s\n${CLR_RESET}" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
	fi

	# [ERR] Always show warn and error
	if [ "${_lvl}" = "err" ]; then
		IFS='
		'
		for line in ${_msg}; do
			printf "${CLR_ERROR}[ERR]   %s\n${CLR_RESET}" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
	fi

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "verbose" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "

		IFS='
		'
		for line in ${_msg}; do
			printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${line}" >> "${_file}"
		done
		unset IFS
	fi
	return 0
}


# Inline Output to stdout/stderr and to file (no newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugi() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "verbose" ] && printf "${CLR_DEBUG}[DEBUG] %s${CLR_RESET}" "${_msg}"
		fi
	fi


	# Always show warn and error
	[ "${_lvl}" = "warn" ] && printf "${CLR_WARNING}[WARN]  %s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"  ] && printf "${CLR_ERROR}[ERR]   %s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "verbose" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "
		printf "%s %s %s %s" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
	fi
	return 0
}

# Output to stdout/stderr and to file (No date output).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugn() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "%s\n" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "verbose" ] && printf "${CLR_DEBUG}%s\n${CLR_RESET}" "${_msg}"
		fi
	fi


	# Always show warn and error
	[ "${_lvl}" = "warn" ] && printf "${CLR_WARNING}%s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"  ] && printf "${CLR_ERROR}%s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr

	# Log to file
	[ "${_log}" = "1"    ] && printf "%s\n" "${_msg}" >> "${_file}"
	return 0
}

# Output to stdout/stderr and to file (simply output a newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @return integer 0
debug_nl() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_log="${2}"		# log to file?
	_file="${3}"	# full path to logfile
	_cron="${4}"	# run for cron?

	# Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "\n"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "verbose" ] && printf "\n"
		fi
	fi

	# Always show warn and error
	[ "${_lvl}" = "warn" ] && printf "\n" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"  ] && printf "\n" 1>&2	# stdout -> stderr

	# Log to file
	[ "${_log}" = "1"    ] && printf "\n" >> "${_file}"
	return 0
}




############################################################
# Math helper
############################################################

# Test if argument is an integer.
#
# @param  mixed
# @return integer	0: is number | 1: not a number
isint(){
	printf '%d' "$1" >/dev/null 2>&1 && return 0 || return 1;
}


# Sum up two numbers.
#
# @param  integer
# @param  integer
# @return integer
sum() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a + b}'
}

# Subtract two numbers.
#
# @param  integer
# @param  integer
# @return integer
sub() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a - b}'
}



############################################################
# Security checker
############################################################

# Get Operating system independent numerical 4-digit chmod value.
#
# @param  string	path to file/folderhttp://www.nowvideo.sx/premium.php
# @return string	numerical chmod (4-digit format)
permission() {
	_file="${1}"

	# e.g. 640
	if [ "$(uname)" = "Linux" ]; then
		# If no special permissions are set (no sticky bit...), linux will
		# only output the 3 digit number
		_perm="$(stat --format '%a' "${_file}")"
	else # Darwin or FreeBSD
		_perm="$(stat -f "%Mp%Lp" "${_file}")"
	fi

	# For special cases check the length and add a leading 0
	_len=$(echo "${_perm}" | awk '{ print length() }')
	if [ "${_len}" = "3" ]; then
		_perm="0${_perm}"
	fi

	echo "${_perm}"
	return 0
}

# Validate chmod value.
#
# @param  string	numerical chmod
# @return boolean	0: valid, 1: invalid
valid_chmod() {
	CHMOD="${1}"

	len="$(echo "${CHMOD}" | awk '{ print length()   }')"


	if [ "${len}" = "3" ]; then

		r="$(echo "${CHMOD}" | awk '{print substr($0,1,1)}')"
		w="$(echo "${CHMOD}" | awk '{print substr($0,2,1)}')"
		x="$(echo "${CHMOD}" | awk '{print substr($0,3,1)}')"


		# Check if it is an integer
		if ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	elif  [ "${len}" = "4" ]; then

		s="$(echo "${CHMOD}" | awk '{print substr($0,1,1)}')"
		r="$(echo "${CHMOD}" | awk '{print substr($0,2,1)}')"
		w="$(echo "${CHMOD}" | awk '{print substr($0,3,1)}')"
		x="$(echo "${CHMOD}" | awk '{print substr($0,4,1)}')"

		# Check if it is an integer
		if ! isint "${s}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$s" -lt 0 ] || [ "$s" -gt 7 ]; then
			return 1
		fi
		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	else
		# Nope!
		return 1
	fi
}


# Compare two chmod values.
#
# @param  string	numerical chmod (3 or 4 digits)
# @param  string	numerical chmod (3 or 4 digits)
# @return boolean	0: equals, 1: unequal
compare_chmod() {
	_CHMOD1="${1}"
	_CHMOD2="${2}"

	_len1=$(echo "${_CHMOD1}" | awk '{ print length()   }')
	_len2=$(echo "${_CHMOD2}" | awk '{ print length()   }')

	if [ "${_len1}" = "${_len2}" ]; then
		if [ "${_CHMOD1}" = "${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "3" ] && [ "${_len2}" = "4" ]; then
		if [ "0${_CHMOD1}" = "${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "4" ] && [ "${_len2}" = "3" ]; then
		if [ "${_CHMOD1}" = "0${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	else
		return 1
	fi
}


# Convert 3-digit or 4-digit chmod to 3-digit umask
#
# @param  string	numerical chmod (3 or 4 digit)
# @return string	3-digit umask
chmod_2_umask() {
	_CHMOD=${1}

	_len=$(echo "${_CHMOD}" | awk '{ print length()   }')

	if [ "${_len}" = "3" ]; then
		r=$(echo "${_CHMOD}" | awk '{print substr($0,1,1)}')
		w=$(echo "${_CHMOD}" | awk '{print substr($0,2,1)}')
		x=$(echo "${_CHMOD}" | awk '{print substr($0,3,1)}')
	elif  [ "${_len}" = "4" ]; then
		r=$(echo "${_CHMOD}" | awk '{print substr($0,2,1)}')
		w=$(echo "${_CHMOD}" | awk '{print substr($0,3,1)}')
		x=$(echo "${_CHMOD}" | awk '{print substr($0,4,1)}')
	fi

	ur="$(sub "7" "${r}")"
	uw="$(sub "7" "${w}")"
	ux="$(sub "7" "${x}")"

	echo "${ur}${uw}${ux}"
}


# Get the real path of a file if it is a symlink
# @param  string	path (file, folder or symlink)
# @return integer	Success
_realpath() {
	_path="$(realpath "${1}" 2>/dev/null)"
	_code="$?"

	# Return found path
	if [ "${_code}" = "0" ]; then
		echo "${_path}"
		return 0
	# Return original path (with error code)
	else
		echo "${_path}"
		return "${_code}"
	fi
}

############################################################
# tmpwatch/tmpreaper checker/helper
############################################################

# Check for correct tmpwatch/tmpreaper value
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return integer   0: success, 1: failure
valid_tmpwatch() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 0 ]; then
			return 0
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	fi

	# Fuck off
	return 1
}

# Get numerical value for tmpwatch/tmpreaper deletions
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return integer   value
get_tmpwatch_value() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		echo "${_val}"
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		echo "${_val}" | sed 's/m//g'
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		echo "${_val}" | sed 's/h//g'
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		echo "${_val}" | sed 's/d//g'
	fi
}

# Get human readable unit for tmpwatch/tmpreaper deletions (plural or singular)
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return string    Human readable unit
get_tmpwatch_unit_name() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "minutes"
		else
			echo "minute"
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "days"
		else
			echo "day"
		fi
	fi
}



############################################################
# Nagios helper
############################################################

# Aggregate nagios exit code.
# OK < Warning < Error < Unknown
# @param  integer The current exit code.
# @param  integer The new exit code
# @output integer The combined exit code
# @return integer The combined exit code
merge_exit_codes() {
	_curr_exit="$1"
	_next_exit="$2"

	# OK
	if [ "${_curr_exit}" = "0" ]; then
		_curr_exit="${_next_exit}"
	# Warning
	elif [ "${_curr_exit}" = "1" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="1"
		fi
	# Error
	elif [ "${_curr_exit}" = "2" ]; then
		_curr_exit="2"
	# Unknown
	elif [ "${_curr_exit}" = "3" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="3"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="3"
		fi
	fi
	echo "${_curr_exit}"
	return ${_curr_exit}
}


############################################################
# Usage/Help/Version
############################################################

#
# Usage
#
print_usage() {
#	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cron] [--verbose] [--test] [--info] [--help] [--version]"
	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cron] [--verbose] [--test] [--help] [--version]"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "[--conf] [--cron] [--verbose]"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--test [--conf] [--verbose]"
#	printf "%s %s %s\n" "      " "${INFO_NAME}" "--info"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--help"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--version"
}

#
# Display program usage
#
print_help() {

	print_usage
	echo
	echo "When invoked without any arguments, it will start dumping databases as"
	echo "defined in mysqldump-secure.conf."
	echo
	echo "--conf            Pass different configuration file than the default one."
	echo "                  E.g.: --conf=/etc/mysqldump-secure-alt.conf"
	echo
	echo "--cron            Use for cron run. It will only output errors and warnings"
	echo "                  and will silence all debug output."
	echo
	echo "--verbose         Show verbose debug output. If in cron mode, verbose output"
	echo "                  will go to the logfile instead of stdout."
	echo
	echo "--test            Test requirements and exit."
	echo
#	echo "--info            Show settings and exit."
#	echo
	echo "--help            Show this help screen."
	echo
	echo "--version         Show version information."
}
# TODO:
# --------
# --info			Shows current configuration and paths
# --cli				Start interactive cli (mysqldump-secure-cli) to show dumps, import dumps, set configs, etc



#
# Display program version and credits
#
print_version() {
	printf "Name:    %s\n" "${INFO_NAME}"
	printf "Version: %s (%s)\n" "${INFO_VERSION}" "${INFO_DATE}"
	printf "Author:  %s (%s)\n" "${INFO_AUTHOR}" "${INFO_GPGKEY}"
	printf "URL:     %s\n" "${INFO_URL}"
	printf "License: %s\n" "${INFO_LICENSE}"
}


################################################################################
#
# ENTRY POINT: ERROR CHECKING
#
################################################################################

############################################################
# 1.) Evaluate cmd arguments
############################################################


_ARG_CONF="0"
_ARG_VERB="0"
_ARG_CRON="0"
_ARG_TEST="0"
_ARG_HELP="0"
_ARG_VERS="0"
_CUS_CONF=""
#_ARG_INFO="0"

#if [ $# -gt 1 ]; then
#	echo "Too many arguments."
#	echo "Type '${INFO_NAME} --help' for available options."
#	exit 1
#fi

while [ $# -gt 0  ]; do
	case "$1" in

		--conf=*)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_CONF="1"
			_CUS_CONF="$(echo "$1" | sed 's/--conf=//g')"
			;;

		--verbose)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_VERB="1"
			;;


		--cron)
			if [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_CRON="1"
			;;

		--test)
			if [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_TEST="1"
			;;

#		--info)
#			_ARG_INFO="1"
#			;;

		--help)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_VERS}" = "1" ] || [ "${_ARG_VERB}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_HELP="1"
			print_help
			exit 0
			;;

		--version)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERB}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_VERS="1"
			print_version
			exit 0
			;;

		*)
			echo "Invalid argument: '${1}'."
			echo "Type '${INFO_NAME} --help' for available options."
			exit 1
			;;
	esac
	shift
done


# Use default config or user specified config file
if [ -z "${_CUS_CONF-}" ]; then
	CONFIG_FILE="${_DEFAULT_CONFIG_FILE}"
else
	CONFIG_FILE="${_CUS_CONF}"
fi


############################################################
# Config File
############################################################

if [ ! -f "${CONFIG_FILE}" ]; then
	debug "err" "(RUN): Configuration file not found in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
	debug "err" "Aborting" "" "" "${_ARG_CRON}"
	exit 1
fi
if [ -L "${CONFIG_FILE}" ]; then
	if _TMP="$(_realpath "${CONFIG_FILE}")" >/dev/null 2>&1; then
		debug "verbose" "(RUN): \$CONFIG_FILE is a symlink. Setting target to: ${_TMP}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		CONFIG_FILE="${_TMP}"
	else
		debug "err"    "(RUN): Cannot resolve symlink of: $CONFIG_FILE" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"    "Aborting"
		exit 1
	fi
fi
if [ ! -r "${CONFIG_FILE}" ]; then
	debug "err" "(RUN): Configuration file is not readable in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
	debug "err" "Aborting" "" "" "${_ARG_CRON}"
	exit 1
fi
if ! compare_chmod "$(permission "${CONFIG_FILE}")" "${_DEFAULT_CONFIG_CHMOD}" > /dev/null 2>&1 ; then
	debug  "warn" "(RUN): Configuration file ${CONFIG_FILE} has dangerous permissions: $(permission "${CONFIG_FILE}"), should be: ${_DEFAULT_CONFIG_CHMOD}" "" "" "${_ARG_CRON}"
	debugi "info" "(RUN): Trying to chmod to ${_DEFAULT_CONFIG_CHMOD}..." "" "" "${_ARG_CRON}"

	if ! chmod ${_DEFAULT_CONFIG_CHMOD} "${CONFIG_FILE}" > /dev/null 2>&1 ; then
		debugn "err" "Failed" "" "" "${_ARG_CRON}"
		debug  "err" "Failed to chmod ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
		debug  "err" "Fix it manually to ${_DEFAULT_CONFIG_CHMOD}" "" "" "${_ARG_CRON}"
		debug  "err" "Aborting" "" "" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "OK" "" "" "${_ARG_CRON}"
	fi
fi



# Read config file
# Comment required by shellcheck,
# See problem here: https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC1090
#
# TODO: Manually parse the file via sed or awk to be safer
. "${CONFIG_FILE}"




############################################################
# Logging Options
############################################################

# Be really strict on checking if we are going to log to file
# or not. Also make sure that the logfile is writeable and
# that no other has read permissions to the file.
if ! set | grep '^LOG=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$LOG variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOG=0
elif [ -z "${LOG}" ]; then
	debug "warn" "(CFG): \$LOG variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOG=0
elif [ "${LOG}" = "1" ]; then
	# Check chmod variable
	if ! set | grep '^LOG_CHMOD=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$LOG_CHMOD variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
	elif [ -z "${LOG_CHMOD}" ]; then
		debug "warn" "(CFG): \$LOG_CHMOD variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
	elif ! valid_chmod "${LOG_CHMOD}" > /dev/null 2>&1; then
		debug "err"  "(CFG): Invalid value for \$LOG_CHMOD: ${LOG_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"  "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
	fi

	# Check logfile variable
	if ! set | grep '^LOGFILE=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$LOGFILE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOGFILE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOGFILE="${_DEFAULT_LOGFILE}"
	elif [ -z "${LOGFILE}" ]; then
		debug "warn" "(CFG): \$LOGFILE variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOGFILE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOGFILE="${_DEFAULT_LOGFILE}"
	fi

	# Resolve symlink?
	if [ -L "${LOGFILE}" ]; then
		if _TMP="$(_realpath "${LOGFILE}")" >/dev/null 2>&1; then
			debug "verbose" "(RUN): \$LOGFILE is a symlink. Setting target to: ${_TMP}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			LOGFILE="${_TMP}"
		else
			debug "err"    "(RUN): Cannot resolve symlink of: $LOGFILE" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err"    "Aborting"
			exit 1
		fi
	fi


	if [ ! -f "${LOGFILE}" ]; then
		# Check if logging directory exists
		if [ ! -d "$(dirname "${LOGFILE}")" ]; then
			debug  "warn" "(RUN): Logfile directory does not exist in $(dirname "${LOGFILE}")" "" "" "${_ARG_CRON}"
			debugi "info" "(RUN): Trying to create..." "" "" "${_ARG_CRON}"
			if ! mkdir -p "$(dirname "${LOGFILE}")" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "" "" "${_ARG_CRON}"
				debug  "err"  "(RUN): Failed to create directoy: $(dirname "${LOGFILE}")" "" "" "${_ARG_CRON}"
				debug  "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
				LOG=0
			else
				debugn "info" "OK" "" "" "${_ARG_CRON}"
			fi
		fi
		# If logging is still OK (dir exists), check if the file can be created
		if [ "${LOG}" = "1" ]; then
			debug  "warn" "(RUN): Logfile does not exist in ${LOGFILE}" "" "" "${_ARG_CRON}"
			debugi "info" "(RUN): Trying to create..." "" "" "${_ARG_CRON}"

			if ! touch "${LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "" "" "${_ARG_CRON}"
				debug  "err"  "(RUN): Failed to create file: ${LOGFILE}" "" "" "${_ARG_CRON}"
				debug  "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}"
				LOG=0
			else
				debugn "info" "OK" "" "" "${_ARG_CRON}"
			fi
		fi
	fi

	# Logging still on?
	# Check for permissions
	if [ "${LOG}" = "1" ]; then
		if ! compare_chmod "$(permission "${LOGFILE}")" "${LOG_CHMOD}" > /dev/null 2>&1 ; then
			debug  "warn" "(RUN): Logfile has wrong permissions: $(permission "${LOGFILE}"), should be: ${LOG_CHMOD}" "" "" "${_ARG_CRON}"
			debugi "info" "(RUN): Trying to chmod to ${LOG_CHMOD}..." "" "" "${_ARG_CRON}"

			if ! chmod ${LOG_CHMOD} "${LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "" "" "${_ARG_CRON}"
				debug  "err"  "(RUN): Failed to chmod ${LOG_CHMOD} ${LOGFILE}" "" "" "${_ARG_CRON}"
				debug  "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}"
				LOG=0
			else
				debugn "info" "OK" "" "" "${_ARG_CRON}"
			fi
		fi
	fi

	# Logging still on?
	# Check if it is writeable
	if [ "${LOG}" = "1" ]; then

		# Logfile not writeable
		if [ ! -w "${LOGFILE}" ]; then
			debug  "err"  "(RUN): Logfile ${LOGFILE} not writeable. Check \$LOG_CHMOD value inf config." "" "" "${_ARG_CRON}"
			debug  "warn" "(OPT): Logging disabled" "" "" "${_ARG_CRON}"
			LOG=0
		fi
	fi
elif [ "${LOG}" = "0" ]; then
	debug "info" "(OPT): Logging disabled" "" "" "${_ARG_CRON}"
else
	debug "err"  "(CFG): Invalid value for \$LOG: ${LOG}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err"  "(OPT): Logging disabled" "" "" "${_ARG_CRON}"
	LOG=0
fi

# Is logging still enabled after all checks?
# Write to the file
if [ "${LOG}" = "1" ]; then
	{
		echo;
		echo "--------------------------------------------------------------------------------";
		echo "$(date '+%Y-%m-%d') $(date '+%H:%M:%S') Starting";
	} >> "${LOGFILE}"
	debug "info" "(CFG): Using config: ${CONFIG_FILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "(OPT): Logging enabled: ${LOGFILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
else
	debug "info" "(CFG): Using config: ${CONFIG_FILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi



############################################################
# Command line arguments
############################################################
if [ "${_ARG_CRON}" = "1" ]; then
	debug "info" "(ARG): Running in cron mode (--cron)." ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi
if [ "${_ARG_TEST}" = "1" ]; then
	debug "info" "(ARG): Running tests only (--test)." ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi
if [ "${_ARG_VERB}" = "1" ]; then
	debug "info" "(ARG): Running in verbose mode (--verbose)." ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi
#if [ "${_ARG_INFO}" = "1" ]; then
#	debug "info" "Showing information only (--info)."  ${LOG} "${LOGFILE}" "${_ARG_CRON}"
#fi


############################################################
# Destination Directory and Prefix
############################################################

# Check $DUMP_DIR_CHMOD
if ! set | grep '^DUMP_DIR_CHMOD=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_DIR_CHMOD variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
elif [ -z "${DUMP_DIR_CHMOD}" ]; then
	debug "warn" "(CFG): \$DUMP_DIR_CHMOD variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
elif ! valid_chmod "${DUMP_DIR_CHMOD}" > /dev/null 2>&1; then
	debug "err"  "(CFG): Invalid value for \$DUMP_DIR_CHMOD: ${DUMP_DIR_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err"  "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD="${_DEFAULT_DUMP_DIR_CHMOD}"
fi

# Check $DUMP_FILE_CHMOD
if ! set | grep '^DUMP_FILE_CHMOD=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_FILE_CHMOD variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
elif [ -z "${DUMP_FILE_CHMOD}" ]; then
	debug "warn" "(CFG): \$DUMP_FILE_CHMOD variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
elif ! valid_chmod "${DUMP_FILE_CHMOD}" > /dev/null 2>&1; then
	debug "err"  "(CFG): Invalid value for \$DUMP_FILE_CHMOD: ${DUMP_FILE_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err"  "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD="${_DEFAULT_DUMP_DIR_CHMOD}"
fi

# Check $DUMP_PATH
if ! set | grep '^DUMP_PATH=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_PATH variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_PATH}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_PATH=${_DEFAULT_DUMP_PATH}
elif [ -z "${DUMP_PATH}" ]; then
	debug "warn" "(CFG): \$DUMP_PATH variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_PATH}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_PATH=${_DEFAULT_DUMP_PATH}
fi

# Resolve symlink?
if [ -L "${DUMP_PATH}" ]; then
	if _TMP="$(_realpath "${DUMP_PATH}")" >/dev/null 2>&1; then
		debug "verbose" "(RUN): \$DUMP_PATH is a symlink. Setting target to: ${_TMP}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		DUMP_PATH="${_TMP}"
	else
		debug "err"    "(RUN): Cannot resolve symlink of: $DUMP_PATH" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"    "Aborting"
		exit 1
	fi
fi

if [ ! -d "${DUMP_PATH}" ]; then
	debug  "warn" "(RUN): Destination dir does not exist: ${DUMP_PATH}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "info" "(RUN): Trying to create... " $LOG "${LOGFILE}" "${_ARG_CRON}"
	if ! mkdir -p "${DUMP_PATH}" > /dev/null 2>&1 ; then
		debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debugi  "info" "(RUN): Trying to chmod to: ${DUMP_DIR_CHMOD}..." $LOG "${LOGFILE}" "${_ARG_CRON}"
		if ! chmod ${DUMP_DIR_CHMOD} "${DUMP_PATH}" >/dev/null 2>&1; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 1
		else
			debugn "info" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}"
		fi
	fi
fi
# Check correct permissions of destination dir
if ! compare_chmod "$(permission "${DUMP_PATH}")" "${DUMP_DIR_CHMOD}" > /dev/null 2>&1 ; then
	debug  "err"  "(RUN): Target directory has wrong permissions: $(permission "${DUMP_PATH}"), but should ${DUMP_DIR_CHMOD}." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "info" "(RUN): Trying to chmod to ${DUMP_DIR_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}"

	if ! chmod "${DUMP_DIR_CHMOD}" "${DUMP_PATH}" > /dev/null 2>&1 ; then
		debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
fi
# Check if destination dir is writeable
if [ ! -w "${DUMP_PATH}" ]; then
	debug  "err"  "(RUN): Destination dir ${DUMP_PATH} is not writeable" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "err"  "(HLP): Fix your configured permissions" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi

# Check $DUMP_FILE_PRE
if ! set | grep '^DUMP_FILE_PRE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_FILE_PRE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_PRE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_PRE=${_DEFAULT_DUMP_FILE_PRE}
elif [ -z "${DUMP_FILE_PRE}" ]; then
	debug "warn" "(CFG): \$DUMP_FILE_PRE variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_PRE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_PRE=${_DEFAULT_DUMP_FILE_PRE}
fi



############################################################
# MySQL
############################################################

# Check Binaries
if ! command -v mysql > /dev/null 2>&1 ; then
	debug "err"  "(RUN): 'mysql' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 2
fi
if ! command -v mysqldump > /dev/null 2>&1 ; then
	debug "err"  "(RUN): 'mysqldump' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 2
fi

# Check $MYSQL_CNF_FILE
if ! set | grep '^MYSQL_CNF_FILE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$MYSQL_CNF_FILE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_MYSQL_CNF_FILE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_CNF_FILE=${_DEFAULT_MYSQL_CNF_FILE}
elif [ -z "${MYSQL_CNF_FILE}" ]; then
	debug "warn" "(CFG): \$MYSQL_CNF_FILE variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_MYSQL_CNF_FILE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_CNF_FILE=${_DEFAULT_MYSQL_CNF_FILE}
fi

# Resolve symlink?
if [ -L "${MYSQL_CNF_FILE}" ]; then
	if _TMP="$(_realpath "${MYSQL_CNF_FILE}")" >/dev/null 2>&1; then
		debug "verbose" "(RUN): \$MYSQL_CNF_FILE is a symlink. Setting target to: ${_TMP}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		MYSQL_CNF_FILE="${_TMP}"
	else
		debug "err"    "(RUN): Cannot resolve symlink of: $MYSQL_CNF_FILE" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"    "Aborting"
		exit 1
	fi
fi

if [ ! -f "${MYSQL_CNF_FILE}" ]; then
	debug "err"  "(RUN): MySQL CNF file not found: ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
elif [ ! -r "${MYSQL_CNF_FILE}" ]; then
	debug "err"  "(RUN): MySQL CNF file is not readable: ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
elif ! compare_chmod "$(permission "${MYSQL_CNF_FILE}")" "${_DEFAULT_MYSQL_CNF_CHMOD}" > /dev/null 2>&1 ; then
	debug "err"  "(RUN): MySQL CNF file has dangerous permissions: $(permission "${MYSQL_CNF_FILE}")." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(HLP): Fix it to ${_DEFAULT_MYSQL_CNF_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(HLP): If you are not alone on the machine, the password inside could have been compromised by now." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(HLP): If so, change your database password." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi

# Check MYSQL_SSL_ENABLE
if ! set | grep '^MYSQL_SSL_ENABLE=' >/dev/null 2>&1; then
	debug "err" "(CFG): \$MYSQL_SSL_ENABLE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err" "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
elif [ -z "${MYSQL_SSL_ENABLE}" ]; then
	debug "err" "(CFG): \$MYSQL_SSL_ENABLE variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err" "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
elif [ "${MYSQL_SSL_ENABLE}" = "1" ]; then
	if ! set | grep '^MYSQL_SSL_CA_PEM=' >/dev/null 2>&1; then
		debug "err" "(CFG): \$MYSQL_SSL_CA_PEM variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	elif [ -z "${MYSQL_SSL_CA_PEM}" ]; then
		debug "err" "(CFG): \$MYSQL_SSL_CA_PEM variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	elif [ ! -f "${MYSQL_SSL_CA_PEM}" ]; then
		debug "err" "(RUN): \$MYSQL_SSL_CA_PEM=\"$MYSQL_SSL_CA_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	fi

	MYSQL_SSL_ARGS="--ssl-ca=${MYSQL_SSL_CA_PEM}"

	# MYSQL_SSL_CLIENT_CERT_PEM
	if [ -n "${MYSQL_SSL_CLIENT_CERT_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_CERT_PEM}" ]; then
			debug "err"  "(RUN): \$MYSQL_SSL_CLIENT_CERT_PEM=\"$MYSQL_SSL_CLIENT_CERT_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "(HLP): Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 1
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-cert=${MYSQL_SSL_CLIENT_CERT_PEM}"
	fi
	# MYSQL_SSL_CLIENT_KEY_PEM
	if [ -n "${MYSQL_SSL_CLIENT_KEY_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_KEY_PEM}" ]; then
			debug "err"  "(RUN): \$MYSQL_SSL_CLIENT_KEY_PEM=\"$MYSQL_SSL_CLIENT_KEY_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "(HLP): Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 1
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-key=${MYSQL_SSL_CLIENT_KEY_PEM}"
	fi

	debug "info" "(OPT): MySQL SSL connection enabled: ${MYSQL_SSL_ARGS}." $LOG "${LOGFILE}" "${_ARG_CRON}"
elif [ "${MYSQL_SSL_ENABLE}" = "0" ]; then
	MYSQL_SSL_ENABLE=0
	MYSQL_SSL_ARGS=""
	debug "info" "(OPT): MySQL SSL connection disabled." $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	debug "err"  "(CFG): Wrong value for \$MYSQL_SSL_ENABLE: $MYSQL_SSL_ENABLE" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi


# Testing MySQL connection
if ! _CONN_ERR="$($(which mysql) --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" -e exit 2>&1)"; then
	debug  "err"  "(RUN): Cannot connect to mysql database." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "err"  "(RUN): Via: $(which mysql) --defaults-file=${MYSQL_CNF_FILE} ${MYSQL_SSL_ARGS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "err"  "(RUN): SQL: ${_CONN_ERR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 3
else
	debug "info" "(RUN): MySQL connection test successful." $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

# Testing MySQL for SSL connection
MYSQL_SSL_STATUS="$($(which mysql) --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" -e 'status;' 2>&1 | grep -E '^SSL:.*' | sed 's/SSL:\s*//g')"
if [ "${MYSQL_SSL_STATUS}" = "Not in use" ]; then
	if [ "${MYSQL_SSL_ENABLE}" = "1" ]; then
		debug "err"  "(RUN): MySQL connection is not using SSL." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debug "info"  "(RUN): MySQL connection is not using SSL." $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	debug "info" "(RUN): MySQL connection is using SSL: ${MYSQL_SSL_STATUS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi




############################################################
# MySQL Dump Opts
############################################################

if ! set | grep '^MYSQL_OPTS=' >/dev/null 2>&1; then
	debug "info" "(CFG): \$MYSQL_OPTS variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS=""
elif [ -z "${MYSQL_SSL_ENABLE}" ]; then
	debug "info" "(CFG): \$MYSQL_OPTS is empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS=""
fi

debug "info"  "(CFG): mysqldump options: ${MYSQL_OPTS}" $LOG "${LOGFILE}" "${_ARG_CRON}"


# Warnings about inconsistent dumps? (IGNORE_CONSISTENT_DUMP_WARNINGS)
if ! set | grep '^IGNORE_CONSISTENT_DUMP_WARNINGS=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$IGNORE_CONSISTENT_DUMP_WARNINGS variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): Will warn you about inconsistent dumps." $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE_CONSISTENT_DUMP_WARNINGS=0
elif [ -z "${IGNORE_CONSISTENT_DUMP_WARNINGS}" ]; then
	debug "warn" "(CFG): \$IGNORE_CONSISTENT_DUMP_WARNINGS variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): Will warn you about inconsistent dumps." $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE_CONSISTENT_DUMP_WARNINGS=0
elif [ "${IGNORE_CONSISTENT_DUMP_WARNINGS}" = "1" ]; then
	debug "info" "(CFG): Will not warn you about inconsistent dumps (unsafe)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info" "(HLP): It is recommended to turn off \$IGNORE_CONSISTENT_DUMP_WARNINGS" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${IGNORE_CONSISTENT_DUMP_WARNINGS}" = "0" ]; then
	debug "info" "(CFG): Will warn you about inconsistent dumps (safe)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err"  "(CFG): \$IGNORE_CONSISTENT_DUMP_WARNINGS variable has an invalid value: ${IGNORE_CONSISTENT_DUMP_WARNINGS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(RUN): Will warn you about inconsistent dumps." $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE_CONSISTENT_DUMP_WARNINGS=0
fi

# Dump consistent?
if ! set | grep '^CONSISTENT_DUMP=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$CONSISTENT_DUMP variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): Intentionally disabling consistent dumps (no '--lock-tables' or '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}"
	CONSISTENT_DUMP=0
elif [ -z "${IGNORE_CONSISTENT_DUMP_WARNINGS}" ]; then
	debug "warn" "(CFG): \$CONSISTENT_DUMP variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): Intentionally disabling consistent dumps (no '--lock-tables' or '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}"
	CONSISTENT_DUMP=0
elif [ "${CONSISTENT_DUMP}" = "1" ]; then
	debug "info" "(CFG): Dumping consistently across tables (using '--lock-tables' or '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}"
elif [ "${CONSISTENT_DUMP}" = "0" ]; then
	debug "info" "(CFG): Not dumping consistently across tables (unsafe)" $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	debug "err"  "(CFG): \$CONSISTENT_DUMP variable has an invalid value: ${CONSISTENT_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "(RUN): Intentionally disabling consistent dumps (no '--lock-tables' or '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}"
	CONSISTENT_DUMP=0
fi



############################################################
# Bad MySQL Opts
############################################################
for opt in ${MYSQL_OPTS}; do
	for evil in ${MYSQL_EVIL_OPTS}; do
		if echo "${opt}" | grep -e "^${evil}" > /dev/null 2>&1; then
			echo "opt: ${opt}   | evil: ${evil}"
			debug "err"  "(CFG): Insecure mysqldump option found in MYSQL_OPTS: '${opt}'" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "(HLP): Remove it. This option is handled by the tool itself." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 3
		fi
	done
	for bad in ${MYSQL_BAD_OPTS}; do
		if echo "${opt}" | grep -e "^${bad}" > /dev/null 2>&1; then
			debug "err"  "(CFG): Disallowed mysqldump option found in MYSQL_OPTS: '${opt}'" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "(HLP): Remove it. This option can be controlled via the configuration file itself." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 3
		fi
	done
done



############################################################
# IGNORE/REQUIRE
############################################################

# Ignored databases
if ! set | grep '^IGNORE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$IGNORE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info" "(RUN): No database will be ignored" $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE=""
elif [ -z "${IGNORE}" ]; then
	debug "info" "(CFG): \$IGNORE variable is empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info" "(RUN): No database will be ignored" $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE=""
else
	debug "info" "(CFG): Ignored DB's: ${IGNORE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
fi

# Required databases
if ! set | grep '^REQUIRE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$REQUIRE variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info" "(RUN): No database will be required" $LOG "${LOGFILE}" "${_ARG_CRON}"
	REQUIRE=""
elif [ -z "${REQUIRE}" ]; then
	debug "info" "(CFG): \$REQUIRE variable is empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info" "(RUN): No database will explicitly be required" $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE=""
else
	debug "info" "(CFG): Required DB's: ${REQUIRE}" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
fi





############################################################
# Compression
############################################################
# Check $DUMP_FILE_PRE
if ! set | grep '^COMPRESS=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$COMPRESS variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
elif [ -z "${COMPRESS}" ]; then
	debug "warn" "(CFG): \$COMPRESS variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
elif [ "${COMPRESS}" = "1" ]; then

	# COMPRESS_BIN
	if ! set | grep '^COMPRESS_BIN=' >/dev/null 2>&1; then
		debug "err" "(CFG): \$COMPRESS_BIN variable is not defined, but required" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		COMPRESS=0
	elif [ -z "${COMPRESS_BIN}" ]; then
		debug "err" "(CFG): \$COMPRESS_BIN variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		COMPRESS=0
	elif ! command -v "${COMPRESS_BIN}" > /dev/null 2>&1 ; then
		debug "err" "(CFG): ${COMPRESS_BIN} not found. Fix \$COMPRESS_BIN" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err" "(HLP): Fix \$COMPRESS_BIN" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
		COMPRESS=0
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		# COMPRESS_ARG
		if ! set | grep '^COMPRESS_ARG=' >/dev/null 2>&1; then
			debug "err" "(CFG): \$COMPRESS_ARG variable is not defined, but required" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS=0
		elif [ -z "${COMPRESS_ARG}" ]; then
			debug "err" "(CFG): \$COMPRESS_ARG variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS=0
		fi
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		# COMPRESS_ARG
		if ! set | grep '^COMPRESS_EXT=' >/dev/null 2>&1; then
			debug "warn" "(CFG): \$COMPRESS_EXT variable is not defined" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Using 'compressed' as file extension." $LOG "${LOGFILE}" "${_ARG_CRON}"
			COMPRESS_EXT="compressed"
		elif [ -z "${COMPRESS_EXT}" ]; then
			debug "warn" "(CFG): \$COMPRESS_EXT variable should not be empty" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Using 'compressed' as file extension." $LOG "${LOGFILE}" "${_ARG_CRON}"
			COMPRESS_EXT="compressed"
		fi
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		debug "info" "(OPT): Compression enabled: Using ${COMPRESS_BIN} ${COMPRESS_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi

elif [ "${COMPRESS}" = "0" ]; then
	debug "info" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	debug "err" "(CFG): Invalid value for \$COMPRESS: ${COMPRESS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err" "(OPT): Compression disabled" "" "" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
fi















############################################################
# Encryption
############################################################
if [ -z "${ENCRYPT-}" ]; then
	debug "warn" "\$ENCRYPT variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Encryption disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	ENCRYPT=0
fi
if [ "${ENCRYPT}" = "1" ]; then
	if ! command -v openssl > /dev/null 2>&1 ; then
		debug "err"  "'openssl' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi
	if [ ! -f "${OPENSSL_PUBKEY_PEM}" ]; then
		debug "err"  "OpenSSL pubkey not found in ${OPENSSL_PUBKEY_PEM}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi
	if [ -z "${OPENSSL_ALGO_ARG-}" ]; then
		debug "warn" "\$OPENSSL_ALGO_ARG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Encryption defaults to: ${OPENSSL_ALGO_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		OPENSSL_ALGO_ARG="${_DEFAULT_OPENSSL_ALGO_ARG}"
	fi
	# Test openssl Algo
	if ! echo "test" | $(which openssl) smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} "${OPENSSL_PUBKEY_PEM}" > /dev/null 2>&1 ; then
		debug "err"  "openssl encryption test failed. Validate \$OPENSSL_ALGO_ARG" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi

	debug "info" "(OPT) Encryption enabled" $LOG "${LOGFILE}" "${_ARG_CRON}"

else
	debug "info" "(OPT) Encryption disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	ENCRYPT="0"
fi



############################################################
# Deletion
############################################################
if [ -z "${DELETE-}" ]; then
	debug "warn" "\$DELETE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DELETE=0
fi
if [ "${DELETE}" = "1"  ]; then
	if [ -z "${DELETE_METHOD-}" ]; then
		debug "warn" "\$DELETE_METHOD variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" = "tmpwatch" ] &&  ! command -v tmpwatch > /dev/null 2>&1 ; then
		debug "warn" "'tmpwatch' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" = "tmpreaper" ] && ! command -v tmpreaper > /dev/null 2>&1 ; then
		debug "warn" "'tmpreaper' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" != "tmpwatch" ] && [ "${DELETE_METHOD}" != 'tmpreaper' ]; then
		debug "warn" "\$DELETE_METHOD must be either 'tmpwatch' or 'tmpreaper' in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ -z "${DELETE_IF_OLDER-}" ]; then
		debug "warn" "\$DELETE_IF_OLDER variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif ! valid_tmpwatch "${DELETE_IF_OLDER}" > /dev/null 2>&1 ; then
		debug "warn" "\$DELETE_IF_OLDER does not have a valid ${DELETE_METHOD} value: ${DELETE_IF_OLDER} (See: man ${DELETE_METHOD})" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	else
		debug "info" "(OPT) Deletion enabled. Deleting files older than $(get_tmpwatch_value "${DELETE_IF_OLDER}") $(get_tmpwatch_unit_name "${DELETE_IF_OLDER}"). Using: ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	debug "info" "(OPT) Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

# Check for forced deletion
if [ "${DELETE}" = "1" ]; then
	if [ -z "${DELETE_FORCE-}" ]; then
		debug "warn" "\$DELETE_FORCE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	elif ! isint "${DELETE_FORCE}" > /dev/null 2>&1 ; then
		debug "warn" "\$DELETE_FORCE variable is not a valid integer" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	elif [ "${DELETE_FORCE}" != "0" ] && [ "${DELETE_FORCE}" != "1" ]; then
		debug "warn" "\$DELETE_FORCE variable invalid. Must be either 0 or 1." $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	fi


	if [ "${DELETE_FORCE}" = 1 ]; then
		debug "info" "${DELETE_METHOD}: Using '--force' option for ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	else
		debug "info" "${DELETE_METHOD}: Not forcing (--force) deletion on read-only files for ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	DELETE="0"
fi



############################################################
# Nagios
############################################################
if [ -z "${NAGIOS_LOG-}" ]; then
	debug "warn" "\$NAGIOS_LOG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	NAGIOS_LOG=0
elif [ "${NAGIOS_LOG}" = "1"  ]; then

	# Checking chmod variable
	if [ -z "${NAGIOS_LOG_CHMOD-}" ]; then
		debug "warn" "\$NAGIOS_LOG_CHMOD variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
	elif ! valid_chmod "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1; then
		debug "err"  "Invalid chmod value for \$NAGIOS_LOG_CHMOD: ${NAGIOS_LOG_CHMOD} in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "info" "Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
	fi

	# Checking logfile variable
	if [ -z "${NAGIOS_LOGFILE-}" ]; then
		debug "warn" "\$NAGIOS_LOG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG=0
	# Check if file exists
	elif [ ! -f "${NAGIOS_LOGFILE}" ]; then
		debug  "warn" "${NAGIOS_LOGFILE} not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debugi "info" "Trying to create..." $LOG "${LOGFILE}" "${_ARG_CRON}"

		if ! touch "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "err"  "Failed to create file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "info" "Created file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debugi "info" "Trying to chmod to ${NAGIOS_LOG_CHMOD}..." $LOG "${LOGFILE}" "${_ARG_CRON}"

			if ! chmod ${NAGIOS_LOG_CHMOD} "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug  "err"  "Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
				NAGIOS_LOG=0
			else
				debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
			fi
		fi
	# Check if it has wrong permissions
	elif ! compare_chmod "$(permission "${NAGIOS_LOGFILE}")" "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1 ; then
		debug  "warn" "Nagios logfile has wrong permissions: $(permission "${NAGIOS_LOGFILE}"), but should be: ${NAGIOS_LOG_CHMOD} " $LOG "${LOGFILE}" "${_ARG_CRON}"
		debugi "info" "Trying to chmod to ${NAGIOS_LOG_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}"
		if ! chmod "${NAGIOS_LOG_CHMOD}" "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "err"  "Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
		fi
	fi

	# Still enabled?
	if [ "${NAGIOS_LOG}" = "1"  ]; then
		if [ ! -r "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "${NAGIOS_LOGFILE} not readable. Fix CHMOD permissions in config." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		elif [ ! -w "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "${NAGIOS_LOGFILE} not writeable. Fix CHMOD permissions in config." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debug "info" "(OPT) Nagios plugin log enabled: ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		fi
	fi

else
	debug "info" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	NAGIOS_LOG="0"
fi



############################################################
# Print additional information
############################################################

debug "info" "Backup directory: ${DUMP_PATH}" $LOG "${LOGFILE}" "${_ARG_CRON}"



############################################################
# Test mode
############################################################
if [ "${_ARG_TEST}" = "1" ]; then
	debug "info" "Exiting program from test mode (--test)."  ${LOG} "${LOGFILE}" "${_ARG_CRON}"
	exit 0
fi


################################################################################
#
# ENTRY POINT: MAIN
#
################################################################################

# Binaries
MYSQL="$(which mysql)"
MYSQLDUMP="$(which mysqldump)"
OPENSSL="$(which openssl)"
TMPWATCH="$(which "${DELETE_METHOD}")"	# This can be tmpwatch or tmpreaper

# Error code for nagios
ERROR=0



############################################################
# Create tmp files and folders
############################################################

if MY_TMP_DIR="$( mktemp -d /tmp/mysqldump-secure.XXXXXXXXXX 2>/dev/null)"; then
	debug "verbose"  "Creating tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err"  "Cannot create tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if MY_TMP_FILE_DUMP="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "verbose"  "Creating tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err"  "Cannot create tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if MY_TMP_FILE_COMP="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "verbose"  "Creating tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err"  "Cannot create tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if MY_TMP_FILE_ENCR="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "verbose"  "Creating tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err"  "Cannot create tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi


############################################################
# Get all databases
############################################################

# Get a list of all databases
debugi "info" "Retrieving list of databases... " $LOG "${LOGFILE}" "${_ARG_CRON}"

# gets all databases (even empty ones)
DATABASES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --batch -e 'show databases;' | sed 1d )"
# Only gets databases which have content (tables)
#DATABASES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --no-auto-rehash --skip-column-names -e 'SELECT DISTINCT table_schema FROM information_schema.tables;')"

NUM_DB="$(echo "${DATABASES}" | wc -l | tr -d ' ')"
debugn "info" "${NUM_DB}" $LOG "${LOGFILE}" "${_ARG_CRON}"



############################################################
# Dump databases
############################################################

TOTAL_STARTTIME=$(date +%s)
TOTAL_SIZE=0
TOTAL_DBS=0
TOTAL_IGN=0
TOTAL_ERR=0

# Get info for nagios log
NAGIOS_DB_DUMPED=""
NAGIOS_DB_IGNORED=""
NAGIOS_DB_ERROR=""


for db in ${DATABASES}; do

	# Reset skip flag
	skip=0

	# If a database does not show up in information_schema.tables, it means it
	# has no tables yet and is therefore empty.
	EMPTY="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --batch \
		-e "SELECT IF(COUNT(*) = 0, 'yes', 'no') AS empty
			FROM INFORMATION_SCHEMA.TABLES
			WHERE TABLE_SCHEMA = '${db}';" | tail -n1 )"

	if [ "${EMPTY}" = "yes" ]; then
		skip=1
	fi

	# Skip databases that are scheduled for skipping in config
	for ign_db in ${IGNORE}; do
		if [ "${ign_db}" = "${db}" ]; then
			skip=2
		fi
	done


	if [ ${skip} -eq 0 ]; then

		# Get file extension
		if [ ${COMPRESS} -eq 1 ]; then
			if [ ${ENCRYPT} -eq 1 ]; then
				ext=".sql.${COMPRESS_EXT}.enc"
			else
				ext=".sql.${COMPRESS_EXT}"
			fi
		else
			if [ ${ENCRYPT} -eq 1 ]; then
				ext=".sql.enc"
			else
				ext=".sql"
			fi
		fi


		# File already exists on disk?
		if [ -f "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" ]; then

			# Increment total dbs error count
			TOTAL_ERR=$((TOTAL_ERR + 1))

			# Add failed db to nagios log
			[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"

			debug "err"  "${db} cannot be written to disk (file exists: ${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext})" $LOG "${LOGFILE}" "${_ARG_CRON}"
			ERROR="$(merge_exit_codes "${ERROR}" 2)"

		# All Good, file can be written
		else

			#
			# REQUIRED DATABASES
			#
			for req in ${REQUIRE}; do
				# Required database found?
				# Remove from variable
				if [ "${db}" = "${req}" ]; then
					REQUIRE="$( echo "${REQUIRE}" | sed "s/${db}//" )"
				fi
			done


			#
			# TABLE ENGINES
			#
			_TABLES_INNODB=""
			_TABLES_MYISAM=""
			_TABLES_OTHER=""
			MYSQL_LOCK_OPTS=""

			# Gather all table engines.
			TBL_ENGINES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} --batch \
				-e "SELECT CONCAT(TABLE_NAME, '#',ENGINE) AS t
					FROM information_schema.TABLES
					WHERE TABLE_SCHEMA = '${db}';" | grep -E '^.*[#].*$')"
			IFS='
			'

			# Assign Dump options to table engines.
			for _line in ${TBL_ENGINES}; do
				_table="$(echo "${_line}" | awk -F '#' '{print $1}')"
				_engine="$(echo "${_line}" | awk -F '#' '{print $2}')"

				if [ "${_engine}" = "InnoDB" ]; then
					[ -z "${_TABLES_INNODB}" ] && _TABLES_INNODB="${_table}" || _TABLES_INNODB="$( printf "%s %s" "${_TABLES_INNODB}" "${_table}")"
				elif  [ "${_engine}" = "MyISAM" ]; then
					[ -z "${_TABLES_MYISAM}" ] && _TABLES_MYISAM="${_table}" || _TABLES_MYISAM="$( printf "%s %s" "${_TABLES_MYISAM}" "${_table}")"
				else
					[ -z "${_TABLES_OTHER}" ] && _TABLES_OTHER="${_table}" || _TABLES_OTHER="$( printf "%s %s" "${_TABLES_OTHER}" "${_table}")"
				fi
			done
			unset IFS

			# Set dump options if consistent dumping is enabled
			if [ "${CONSISTENT_DUMP}" = "1" ]; then

				# information_schema and performance schema are special tables, which do not allow locking
				if [ "${db}" = "information_schema" ] || [ "${db}" = "performance_schema" ]; then
					debug "verbose" "\"${db}\" cannot be dumped with --lock-tables. Adding --skip-lock-tables" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--skip-lock-tables"
				# All other tables
				else
					if [ "${_TABLES_MYISAM}" != "" ]; then
						debug "verbose" "Some tables use MyISAM (${_TABLES_MYISAM}). Dumping with --lock-tables" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
						MYSQL_LOCK_OPTS="--lock-tables"
					elif [ "${_TABLES_OTHER}" != "" ]; then
						debug "verbose" "Some tables use an unknown Engine (${_TABLES_OTHER}). Dumping with --lock-tables" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
						MYSQL_LOCK_OPTS="--lock-tables"
					else
						debug "verbose" "All tables use InnoDB. Dumping with --single-transaction" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
						MYSQL_LOCK_OPTS="--single-transaction"
					fi
				fi
			else
				debug "warn" "Not dumping consistently with '--lock-tables' or '--single-transaction'. Turn on via \$CONSISTENT_DUMP" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			fi


			#
			# DATABASE SIZE
			#
			DB_SIZE="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} --batch \
				-e "SELECT SUM(ROUND(((DATA_LENGTH + INDEX_LENGTH ) / 1024 / 1024),2)) AS Size
					FROM INFORMATION_SCHEMA.TABLES
					WHERE TABLE_SCHEMA = '${db}';" | tail -n1 )"

			TOTAL_SIZE=$( sum "${TOTAL_SIZE}" "${DB_SIZE}" )


			#
			# RESET pipefail VARIABLE
			#
			error_statuses=""


			#
			# TRACK TIME
			#
			starttime=$(date +%s)


			#
			# GO GO GO!
			#
			if [ ${COMPRESS} -eq 1 ]; then
				#
				# Case 1/4 Compressed & Encrypted
				#
				if [ ${ENCRYPT} -eq 1 ]; then
					ext=".sql.${COMPRESS_EXT}.enc"
					debugi "info"  "Dumping:  ${db} (${DB_SIZE} MB) (compressed) (encrypted) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) " )" $LOG "${LOGFILE}" "${_ARG_CRON}"


					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					error_statuses="$( (
						(if ${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}"; then
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						else
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						fi) |
						(if ${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}"; then
							echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3;
						else
							echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3
						fi) |
						(if ${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}"; then
							echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3;
						else
							echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3;
						fi)
					) 3>&1 >&4)"
					exec 4>&-
				#
				# Case 2/4 Compressed Only
				#
				else
					ext=".sql.${COMPRESS_EXT}"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) (compressed) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) " )" $LOG "${LOGFILE}" "${_ARG_CRON}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")"

					# POSIX pipefail emulation
					exec 4>&1
					error_statuses="$( (
						(if ${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}"; then
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						else
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						fi) |
						(if ${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}" > "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}"; then
							echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3;
						else
							echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3
						fi)
					) 3>&1 >&4)"
					exec 4>&-

				fi
			else
				#
				# Case 3/4 Encrypted Only
				#
				if [ ${ENCRYPT} -eq 1 ]; then
					ext=".sql.enc"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) (encrypted) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) " )" $LOG "${LOGFILE}" "${_ARG_CRON}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					error_statuses="$( (
						(if ${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}"; then
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						else
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						fi) |
						(if ${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}"; then
							echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3;
						else
							echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3;
						fi)
					) 3>&1 >&4)"
					exec 4>&-
				#
				# Case 4/4 Plain
				#
				else
					ext=".sql"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) " )" $LOG "${LOGFILE}" "${_ARG_CRON}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					error_statuses="$( (
						(if ${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}" > "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}"; then
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						else
							echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3;
						fi)
					) 3>&1 >&4)"
					exec 4>&-
				fi
			fi


			#
			# Error Checking
			#
			# Inside $error_statuses we have the following information.
			# Note: Not all lines must be there (depends on enabled options)
			#
			# "0:<exit code>:<stderr msg>"   <--mysqldump
			# "1:<exit code>:<stderr msg>"   <--compression
			# "2:<exit code>:<stderr msg>"   <--openssl
			#
			# Cases:
			#  1. Error code == 0 and <stderr msg> empty      => OK
			#  2. Error code == 0 and <stderr msg> not empty  => Warning
			#  3. Error code != 0                             => Error
			MY_ERRORS=""
			MY_WARNINGS=""

			IFS='
			'
			for _err in ${error_statuses}; do
				_type="$( echo "${_err}" | awk -F ':' '{print $1}' )"
				_exit="$( echo "${_err}" | awk -F ':' '{print $2}' )"
				_msg="$(  echo "${_err}" | awk -F ':' '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )"

				if [ "${_type}" = "0" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="mysqldump: ${_msg}" || MY_ERRORS="$( printf "%s\nmysqldump: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="mysqldump: ${_msg}" || MY_WARNINGS="$( printf "%s\nmysqldump: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				elif [ "${_type}" = "1" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="compression: ${_msg}" || MY_ERRORS="$( printf "%s\ncompression: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="compression: ${_msg}" || MY_WARNINGS="$( printf "%s\ncompression: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				elif [ "${_type}" = "2" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="encryption: ${_msg}" || MY_ERRORS="$( printf "%s\nencryption: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="encryption: ${_msg}" || MY_WARNINGS="$( printf "%s\nencryption: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				fi
			done
			unset IFS


			#
			# Error Evaluation
			#
			if [ "${MY_ERRORS}" != "" ]; then
				TOTAL_ERR=$((TOTAL_ERR + 1))

				debug_nl "info" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug    "err"  "Error dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debugr   "err"  "${MY_ERRORS}" $LOG "${LOGFILE}" "${_ARG_CRON}"

				ERROR="$(merge_exit_codes "${ERROR}" 2)"
				[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"
			else
				TOTAL_DBS=$((TOTAL_DBS + 1))
				endtime=$(date +%s)

				debugn "info" "$((endtime - starttime)) sec" $LOG "${LOGFILE}" "${_ARG_CRON}"

				[ "${NAGIOS_DB_DUMPED}" = "" ] && NAGIOS_DB_DUMPED="${db}" || NAGIOS_DB_DUMPED="${NAGIOS_DB_DUMPED},${db}"

				if [ "${MY_WARNINGS}" != "" ]; then
					debug  "warn" "Warning dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}"
					debugr "warn" "${MY_WARNINGS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				fi
			fi

			# Debug output.
			debugr "verbose" "${error_statuses}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi

	elif [ ${skip} -eq 1 ]; then
		debug "info" "Skipping: ${db} (DB is empty)" $LOG "${LOGFILE}" "${_ARG_CRON}"
		TOTAL_IGN=$((TOTAL_IGN + 1))
		[ "${NAGIOS_DB_IGNORED}" = "" ] && NAGIOS_DB_IGNORED="${db}" || NAGIOS_DB_IGNORED="${NAGIOS_DB_IGNORED},${db}"
	else
		debug "info" "Skipping: ${db} (IGNORE=\"${db}\" in config)" $LOG "${LOGFILE}" "${_ARG_CRON}"
		TOTAL_IGN=$((TOTAL_IGN + 1))
		[ "${NAGIOS_DB_IGNORED}" = "" ] && NAGIOS_DB_IGNORED="${db}" || NAGIOS_DB_IGNORED="${NAGIOS_DB_IGNORED},${db}"
	fi

done
TOTAL_ENDTIME=$(date +%s)


for req in ${REQUIRE}; do
	debug "err" "Required database: \"${req}\" has not been dumped." $LOG "${LOGFILE}" "${_ARG_CRON}"
	ERROR="$(merge_exit_codes "${ERROR}" 2)"
done


debug "info" "Dumping finished (OK: ${TOTAL_DBS} dbs, IGN: ${TOTAL_IGN} dbs, ERR: ${TOTAL_ERR}, TOTAL: ${NUM_DB})" $LOG "${LOGFILE}" "${_ARG_CRON}"
debug "info" "Took $((TOTAL_ENDTIME - TOTAL_STARTTIME)) seconds" $LOG "${LOGFILE}" "${_ARG_CRON}"
debug "info" "Total size dumped: ${TOTAL_SIZE} MB" $LOG "${LOGFILE}" "${_ARG_CRON}"





############################################################
# Delete old Files
############################################################
if [ ${DELETE} -eq 1 ]; then

	# Force deletion?
	[ "${DELETE_FORCE}" = "1" ] && FORCE_ARG="--force" || FORCE_ARG=""

	DELETED="$(${TMPWATCH} ${FORCE_ARG} -m "$DELETE_IF_OLDER" -v "${DUMP_PATH}/")"
	if [ $? -ne 0 ]; then
		ERROR="$(merge_exit_codes "${ERROR}" 1)"
	fi
	NUM_DEL="$( echo "${DELETED}" | grep -ci 'Removing' )"
	debug  "info" "Deleting files older than ${DELETE_IF_OLDER} hours... ${NUM_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "info" "${DELETED}" $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	NUM_DEL="0"
fi



############################################################
# Nagios Plugin Log
############################################################
if [ "${NAGIOS_LOG}" = "1" ]; then
	debug "info" "Writing nagios logfile" $LOG "${LOGFILE}" "${_ARG_CRON}"

	{
		echo "[state]";
		echo "success = ${ERROR}";
		echo "lastbak = ${TOTAL_STARTTIME}";
		echo "message = ";
		echo "missing = ${REQUIRE}";
		echo;
		echo "[options]";
		echo "opt_log = ${LOG}";
		echo "opt_com = ${COMPRESS}";
		echo "opt_enc = ${ENCRYPT}";
		echo "opt_del = ${DELETE}";
		echo;
		echo "[messages]";
		echo "msg_dbs = ${TOTAL_DBS}";
		echo "msg_ign = ${TOTAL_IGN}";
		echo "msg_err = ${TOTAL_ERR}";
		echo "msg_meg = ${TOTAL_SIZE}";
		echo "msg_sec = $((TOTAL_ENDTIME - TOTAL_STARTTIME))";
		echo "msg_del = ${NUM_DEL}";
		echo;
		echo "[tmpwatch]";
	} > "${NAGIOS_LOGFILE}"

	if [ "${DELETE}" = "1" ]; then
		echo "del_time = ${DELETE_IF_OLDER}" >> "${NAGIOS_LOGFILE}"
	else
		echo "del_time = 0"	>> "${NAGIOS_LOGFILE}"
	fi

	{
		echo "[stats]";
		echo "db_dumped = ${NAGIOS_DB_DUMPED}";
		echo "db_error = ${NAGIOS_DB_ERROR}";
		echo "db_ignored = ${NAGIOS_DB_IGNORED}"
	} >> "${NAGIOS_LOGFILE}"

fi


############################################################
# Delete temporary files
############################################################

if rm "${MY_TMP_FILE_DUMP}" 2>/dev/null; then
	debug "verbose"  "Deleting tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if rm "${MY_TMP_FILE_COMP}" 2>/dev/null; then
	debug "verbose"  "Deleting tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if rm "${MY_TMP_FILE_ENCR}" 2>/dev/null; then
	debug "verbose"  "Deleting tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

if rm -rf "${MY_TMP_DIR}" 2>/dev/null; then
	debug "verbose"  "Deleting tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "Cannot delete tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi



############################################################
# Exit
############################################################

if [ "${ERROR}" != "0" ]; then
	# Send bad exit code
	debug "err"  "[FAIL] Finished with errors" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 4
else
	# Send good exit code
	debug "info" "[OK] Finished successfully" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 0
fi
