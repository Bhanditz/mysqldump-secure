#!/bin/sh -u
#
# -u: nounset (enable: set -u | disable: set +u)
# -e: errexit
# -r: restricted
#
# Script to dump databases one by one
#
# Exit Codes
# ---------------------
# * 0: Success
# * 1: Script specific: (writeable directory, config file not found, wrong permissions)
# * 2: Required binary not found
# * 3: MySQL connection error
# * 4: MySQL Database dump error

INFO_NAME="mysqldump-secure"
INFO_AUTHOR="Patrick Plocke <patrick@plocke.de>"
INFO_GPGKEY="0x28BF179F"
INFO_LICENSE="MIT"
INFO_URL="https://github.com/cytopia/mysqldump-secure"
INFO_DATE="2016-02-21"
INFO_VERSION="0.16"


################################################################################
#
# AUTO-GENERATED
#
################################################################################

# The following are auto-generated variables by the installer.
# to determine where the script and its config files are installed.
_PREFIX_ETC=""
#_PREFIX_BIN=""
#_PREFIX_LOG=""



################################################################################
#
# DEFAULT VARIABLES
#
################################################################################

#
# Do not djust the following default variables!
# They can be overwritten inside mysqldump-secure.conf
# or via command line arguments
#

# Default Configuration Path/Name
_DEFAULT_CONFIG_FILE="${_PREFIX_ETC}/etc/mysqldump-secure.conf"
_DEFAULT_CONFIG_CHMOD="0400"

# Default output Variables
_DEFAULT_DUMP_FILE_PRE="$(date '+%Y-%m-%d')_$(date '+%H-%M')__"
_DEFAULT_DUMP_FILE_CHMOD="0400"
_DEFAULT_DUMP_DIR_CHMOD="0700"

_DEFAULT_MYSQL_CNF_CHMOD="0400"

# Default OpenSSL Variables
_DEFAULT_OPENSSL_ALGO_ARG="-aes256"

_DEFAULT_LOG_CHMOD="0600"

# Default nagios variables
_DEFAULT_NAGIOS_LOG_CHMOD="0644"


# These command line arguments are considered insecure and can lead
# to compromising your data
MYSQL_EVIL_OPTS="--password -p"

# Do not allow to read any other MySQL configuration file
# than the one specified in the configuration.
# Also all SSL Options are done via configuration
MYSQL_BAD_OPTS="--defaults-extra-file --defaults-file --ssl --ssl-ca --ssl-cert --ssl-key"



################################################################################
#
# F U N C T I O N S
#
################################################################################

############################################################
# Output wrapper
############################################################

# Output to stdout/stderr and to file (with newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debug() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s\n" "${_msg}"
	fi

	# Show debug output?
	if [ "${_debug}" = "1" ]; then
		[ "${_lvl}" = "debug" ] && printf "[DEBUG] %s\n" "${_msg}"
	fi

	# Always show warn and error
	[ -t 1 ] && tput setaf 3
	[ "${_lvl}" = "warn" ] && printf "[WARN]  %s\n" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 1
	[ "${_lvl}" = "err"  ] && printf "[ERR]   %s\n" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 7
	[ -t 1 ] && tput sgr0

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "
		printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
	fi
	return 0
}


# Output to stdout/stderr and to file (with multiple lines).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugr() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# [INFO] Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		if [ "${_lvl}" = "info" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "[INFO]  %s\n" "${line}"
			done
			unset IFS
		fi
	fi

	# [DEBUG] Show debug output?
	if [ "${_debug}" = "1" ]; then
		if [ "${_lvl}" = "debug" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "[DEBUG] %s\n" "${line}"
			done
			unset IFS
		fi
	fi


	# [WARN] Always show warn and error
	if [ "${_lvl}" = "warn" ]; then
		[ -t 1 ] && tput setaf 3
		IFS='
		'
		for line in ${_msg}; do
			printf "[WARN]  %s\n" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
		[ -t 1 ] && tput setaf 7
		[ -t 1 ] && tput sgr0
	fi

	# [ERR] Always show warn and error
	if [ "${_lvl}" = "err" ]; then
		[ -t 1 ] && tput setaf 1
		IFS='
		'
		for line in ${_msg}; do
			printf "[ERR]   %s\n" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
		[ -t 1 ] && tput setaf 7
		[ -t 1 ] && tput sgr0
	fi

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "

		IFS='
		'
		for line in ${_msg}; do
			printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${line}" >> "${_file}"
		done
		unset IFS
	fi
	return 0
}


# Inline Output to stdout/stderr and to file (no newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugi() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s" "${_msg}"
	fi

	# Show debug output?
	if [ "${_debug}" = "1" ]; then
		[ "${_lvl}" = "debug" ] && printf "[DEBUG] %s" "${_msg}"
	fi


	# Always show warn and error
	[ -t 1 ] && tput setaf 3
	[ "${_lvl}" = "warn" ] && printf "[WARN]  %s" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 1
	[ "${_lvl}" = "err"  ] && printf "[ERR]   %s" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 7
	[ -t 1 ] && tput sgr0

	# Log to file
	if [ "${_log}" = "1"    ]; then
		_pre=""
		[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
		[ "${_lvl}" = "info" ]  && _pre="[INFO] "
		[ "${_lvl}" = "warn" ]  && _pre="[WARN] "
		[ "${_lvl}" = "err" ]   && _pre="[ERR]  "
		printf "%s %s %s %s" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
	fi
	return 0
}

# Output to stdout/stderr and to file (No date output).
#
# @param  string  _lvl	Debug Level
# @param  string  _msg	Output message
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @param  string  _debug '1': Show debug output | else: do not show debug output
# @return integer 0
debugn() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6-0}"	# run in debug mode?

	# Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "%s\n" "${_msg}"
	fi

	# Show debug output?
	if [ "${_debug}" = "1" ]; then
		[ "${_lvl}" = "debug" ] && printf "%s\n" "${_msg}"
	fi


	# Always show warn and error
	[ -t 1 ] && tput setaf 3
	[ "${_lvl}" = "warn" ] && printf "%s\n" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 1
	[ "${_lvl}" = "err"  ] && printf "%s\n" "${_msg}" 1>&2	# stdout -> stderr
	[ -t 1 ] && tput setaf 7
	[ -t 1 ] && tput sgr0

	# Log to file
	[ "${_log}" = "1"    ] && printf "%s\n" "${_msg}" >> "${_file}"
	return 0
}

# Output to stdout/stderr and to file (simply output a newline).
#
# @param  string  _lvl	Debug Level
# @param  string  _log	'1': log to file | else: do not log to file
# @param  string  _file	Full path to logfile
# @param  string  _cron '1': Cron usage - do not print 'info' | else: print all
# @return integer 0
debug_nl() {
	_lvl="${1}"		# Loglevel: "info", "warn" or "err"
	_log="${2}"		# log to file?
	_file="${3}"	# full path to logfile
	_cron="${4}"	# run for cron?

	# Hide info output when in cron-mode
	if [ "${_cron}" != "1" ]; then
		[ "${_lvl}" = "info" ] && printf "\n"
	fi

	# Always show warn and error
	[ "${_lvl}" = "warn" ] && printf "\n" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"  ] && printf "\n" 1>&2	# stdout -> stderr

	# Log to file
	[ "${_log}" = "1"    ] && printf "\n" >> "${_file}"
	return 0
}




############################################################
# Math helper
############################################################

# Test if argument is an integer.
#
# @param  mixed
# @return integer	0: is number | 1: not a number
isint(){
	printf '%d' "$1" >/dev/null 2>&1 && return 0 || return 1;
}


# Sum up two numbers.
#
# @param  integer
# @param  integer
# @return integer
sum() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a + b}'
}

# Subtract two numbers.
#
# @param  integer
# @param  integer
# @return integer
sub() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a - b}'
}



############################################################
# Security checker
############################################################

# Get Operating system independent numerical 4-digit chmod value.
#
# @param  string	path to file/folderhttp://www.nowvideo.sx/premium.php
# @return string	numerical chmod (4-digit format)
permission() {
	_file="${1}"

	# e.g. 640
	if [ "$(uname)" = "Linux" ]; then
		# If no special permissions are set (no sticky bit...), linux will
		# only output the 3 digit number
		_perm="$(stat --format '%a' "${_file}")"
	else # Darwin or FreeBSD
		_perm="$(stat -f "%Mp%Lp" "${_file}")"
	fi

	# For special cases check the length and add a leading 0
	_len=$(echo "${_perm}" | awk '{ print length() }')
	if [ "${_len}" = "3" ]; then
		_perm="0${_perm}"
	fi

	echo "${_perm}"
	return 0
}

# Validate chmod value.
#
# @param  string	numerical chmod
# @return boolean	0: valid, 1: invalid
valid_chmod() {
	CHMOD="${1}"

	len="$(echo "${CHMOD}" | awk '{ print length()   }')"


	if [ "${len}" = "3" ]; then

		r="$(echo "${CHMOD}" | awk '{print substr($0,1,1)}')"
		w="$(echo "${CHMOD}" | awk '{print substr($0,2,1)}')"
		x="$(echo "${CHMOD}" | awk '{print substr($0,3,1)}')"


		# Check if it is an integer
		if ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	elif  [ "${len}" = "4" ]; then

		s="$(echo "${CHMOD}" | awk '{print substr($0,1,1)}')"
		r="$(echo "${CHMOD}" | awk '{print substr($0,2,1)}')"
		w="$(echo "${CHMOD}" | awk '{print substr($0,3,1)}')"
		x="$(echo "${CHMOD}" | awk '{print substr($0,4,1)}')"

		# Check if it is an integer
		if ! isint "${s}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$s" -lt 0 ] || [ "$s" -gt 7 ]; then
			return 1
		fi
		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	else
		# Nope!
		return 1
	fi
}


# Compare two chmod values.
#
# @param  string	numerical chmod (3 or 4 digits)
# @param  string	numerical chmod (3 or 4 digits)
# @return boolean	0: equals, 1: unequal
compare_chmod() {
	_CHMOD1="${1}"
	_CHMOD2="${2}"

	_len1=$(echo "${_CHMOD1}" | awk '{ print length()   }')
	_len2=$(echo "${_CHMOD2}" | awk '{ print length()   }')

	if [ "${_len1}" = "${_len2}" ]; then
		if [ "${_CHMOD1}" = "${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "3" ] && [ "${_len2}" = "4" ]; then
		if [ "0${_CHMOD1}" = "${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "4" ] && [ "${_len2}" = "3" ]; then
		if [ "${_CHMOD1}" = "0${_CHMOD2}" ]; then
			return 0
		else
			return 1
		fi
	else
		return 1
	fi
}


# Convert 3-digit or 4-digit chmod to 3-digit umask
#
# @param  string	numerical chmod (3 or 4 digit)
# @return string	3-digit umask
chmod_2_umask() {
	_CHMOD=${1}

	_len=$(echo "${_CHMOD}" | awk '{ print length()   }')

	if [ "${_len}" = "3" ]; then
		r=$(echo "${_CHMOD}" | awk '{print substr($0,1,1)}')
		w=$(echo "${_CHMOD}" | awk '{print substr($0,2,1)}')
		x=$(echo "${_CHMOD}" | awk '{print substr($0,3,1)}')
	elif  [ "${_len}" = "4" ]; then
		r=$(echo "${_CHMOD}" | awk '{print substr($0,2,1)}')
		w=$(echo "${_CHMOD}" | awk '{print substr($0,3,1)}')
		x=$(echo "${_CHMOD}" | awk '{print substr($0,4,1)}')
	fi

	ur="$(sub "7" "${r}")"
	uw="$(sub "7" "${w}")"
	ux="$(sub "7" "${x}")"

	echo "${ur}${uw}${ux}"
}

############################################################
# tmpwatch/tmpreaper checker/helper
############################################################

# Check for correct tmpwatch/tmpreaper value
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return integer   0: success, 1: failure
valid_tmpwatch() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 0 ]; then
			return 0
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	fi

	# Fuck off
	return 1
}

# Get numerical value for tmpwatch/tmpreaper deletions
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return integer   value
get_tmpwatch_value() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		echo "${_val}"
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		echo "${_val}" | sed 's/m//g'
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		echo "${_val}" | sed 's/h//g'
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		echo "${_val}" | sed 's/d//g'
	fi
}

# Get human readable unit for tmpwatch/tmpreaper deletions (plural or singular)
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return string    Human readable unit
get_tmpwatch_unit_name() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "minutes"
		else
			echo "minute"
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "days"
		else
			echo "day"
		fi
	fi
}



############################################################
# Nagios helper
############################################################

# Aggregate nagios exit code.
# OK < Warning < Error < Unknown
# @param  integer The current exit code.
# @param  integer The new exit code
# @output integer The combined exit code
# @return integer The combined exit code
merge_exit_codes() {
	_curr_exit="$1"
	_next_exit="$2"

	# OK
	if [ "${_curr_exit}" = "0" ]; then
		_curr_exit="${_next_exit}"
	# Warning
	elif [ "${_curr_exit}" = "1" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="1"
		fi
	# Error
	elif [ "${_curr_exit}" = "2" ]; then
		_curr_exit="2"
	# Unknown
	elif [ "${_curr_exit}" = "3" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="3"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="3"
		fi
	fi
	echo "${_curr_exit}"
	return ${_curr_exit}
}


############################################################
# Usage/Help/Version
############################################################

#
# Usage
#
print_usage() {
#	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cron] [--test] [--info] [--help] [--version]"
	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cron] [--test] [--help] [--version]"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "[--conf]"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--cron [--conf]"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--test [--conf]"
#	printf "%s %s %s\n" "      " "${INFO_NAME}" "--info"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--help"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--version"
}

#
# Display program usage
#
print_help() {

	print_usage
	echo
	echo "When invoked without any arguments, it will start dumping databases as"
	echo "defined in mysqldump-secure.conf."
	echo
	echo "--conf            Pass different configuration file than the default one."
	echo "                  E.g.: --conf=/etc/mysqldump-secure-alt.conf"
	echo
	echo "--cron            Use for cron run. It will only output errors and warnings"
	echo "                  and will silence all debug output."
	echo
	echo "--test            Test requirements and exit."
	echo
#	echo "--info            Show settings and exit."
#	echo
	echo "--help            Show this help screen."
	echo
	echo "--version         Show version information."
}
# TODO:
# --------
# --info			Shows current configuration and paths
# --cli				Start interactive cli (mysqldump-secure-cli) to show dumps, import dumps, set configs, etc



#
# Display program version and credits
#
print_version() {
	printf "Name:    %s\n" "${INFO_NAME}"
	printf "Version: %s (%s)\n" "${INFO_VERSION}" "${INFO_DATE}"
	printf "Author:  %s (%s)\n" "${INFO_AUTHOR}" "${INFO_GPGKEY}"
	printf "URL:     %s\n" "${INFO_URL}"
	printf "License: %s\n" "${INFO_LICENSE}"
}


################################################################################
#
# ENTRY POINT: ERROR CHECKING
#
################################################################################

############################################################
# 1.) Evaluate cmd arguments
############################################################


_ARG_CONF="0"
_ARG_CRON="0"
_ARG_TEST="0"
_ARG_HELP="0"
_ARG_VERS="0"
_CUS_CONF=""
#_ARG_INFO="0"

#if [ $# -gt 1 ]; then
#	echo "Too many arguments."
#	echo "Type '${INFO_NAME} --help' for available options."
#	exit 1
#fi

while [ $# -gt 0  ]; do
	case "$1" in

		--conf=*)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_CONF="1"
			_CUS_CONF="$(echo "$1" | sed 's/--conf=//g')"
			;;

		--cron)
			if [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_CRON="1"
			;;

		--test)
			if [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_TEST="1"
			;;

#		--info)
#			_ARG_INFO="1"
#			;;

		--help)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_HELP="1"
			print_help
			exit 0
			;;

		--version)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ]; then
				echo "Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit 1
			fi
			_ARG_VERS="1"
			print_version
			exit 0
			;;

		*)
			echo "Invalid argument: '${1}'."
			echo "Type '${INFO_NAME} --help' for available options."
			exit 1
			;;
	esac
	shift
done


# Use default config or user specified config file
if [ -z "${_CUS_CONF-}" ]; then
	CONFIG_FILE="${_DEFAULT_CONFIG_FILE}"
else
	CONFIG_FILE="${_CUS_CONF}"
fi


############################################################
# Config File
############################################################

if [ ! -f "${CONFIG_FILE}" ]; then
	debug "err" "Configuration file not found in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
	debug "err" "Aborting" "" "" "${_ARG_CRON}"
	exit 1
fi
if [ ! -r "${CONFIG_FILE}" ]; then
	debug "err" "Configuration file is not readable in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
	debug "err" "Aborting" "" "" "${_ARG_CRON}"
	exit 1
fi
if ! compare_chmod "$(permission "${CONFIG_FILE}")" "${_DEFAULT_CONFIG_CHMOD}" > /dev/null 2>&1 ; then
	debug  "warn" "Configuration file ${CONFIG_FILE} has dangerous permissions: $(permission "${CONFIG_FILE}"), should be: ${_DEFAULT_CONFIG_CHMOD}" "" "" "${_ARG_CRON}"
	debugi "info" "Trying to chmod to ${_DEFAULT_CONFIG_CHMOD}..." "" "" "${_ARG_CRON}"

	if ! chmod ${_DEFAULT_CONFIG_CHMOD} "${CONFIG_FILE}" > /dev/null 2>&1 ; then
		debugn "err" "Failed" "" "" "${_ARG_CRON}"
		debug  "err" "Failed to chmod ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
		debug  "err" "Fix it manually to ${_DEFAULT_CONFIG_CHMOD}" "" "" "${_ARG_CRON}"
		debug  "err" "Aborting" "" "" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "OK" "" "" "${_ARG_CRON}"
	fi
fi



# Read config file
# Comment required by shellcheck,
# See problem here: https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC1090
. "${CONFIG_FILE}"




############################################################
# Logging Options
############################################################

# Be really strict on checking if we are going to log to file
# or not. Also make sure that the logfile is writeable and
# that no other has read permissions to the file.
if [ -z "${LOG-}" ]; then
	debug "warn" "\$LOG variable is not set or empty in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
	debug "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
	LOG=0
elif [ "${LOG}" = "1" ]; then

	# Check chmod variable
	if [ -z "${LOG_CHMOD-}" ]; then
		debug "warn" "\$LOG_CHMOD variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting default to ${_DEFAULT_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
	elif ! valid_chmod "${LOG_CHMOD}" > /dev/null 2>&1; then
		debug "err"  "Invalid chmod value for \$LOG_CHMOD: ${LOG_CHMOD} in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "info" "Setting default to ${_DEFAULT_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
	fi

	# Check logfile variable
	if [ -z "${LOGFILE-}" ]; then
		debug "warn" "\$LOGFILE variable is not set or empty in ${CONFIG_FILE}" "" "" "${_ARG_CRON}"
		debug "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
		LOG=0
	fi

	# Logging still on?
	# Check for file
	if [ "${LOG}" = "1" ]; then
		# Logfile not found
		if [ ! -f "${LOGFILE}" ]; then

			# Check if logging directory exists
			if [ ! -d "$(dirname "${LOGFILE}")" ]; then
				debug  "warn" "Logfile directory does not exist in $(dirname "${LOGFILE}")" "" "" "${_ARG_CRON}"
				debugi "info" "Trying to create..." "" "" "${_ARG_CRON}"
				if ! mkdir -p "$(dirname "${LOGFILE}")" > /dev/null 2>&1 ; then
					debugn "err"  "Failed" "" "" "${_ARG_CRON}"
					debug  "err"  "Failed to create logfile directoy $(dirname "${LOGFILE}")" "" "" "${_ARG_CRON}"
					debug  "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
					LOG=0
				else
					debugn "info" "OK" "" "" "${_ARG_CRON}"
				fi
			fi

			# If logging is still OK (dir exists), check if the file can be created
			if [ "${LOG}" = "1" ]; then
				debug  "warn" "Logfile does not exist in ${LOGFILE}" "" "" "${_ARG_CRON}"
				debugi "info" "Trying to create..." "" "" "${_ARG_CRON}"

				if ! touch "${LOGFILE}" > /dev/null 2>&1 ; then
					debugn "err"  "Failed" "" "" "${_ARG_CRON}"
					debug  "err"  "Failed to create file ${LOGFILE}" "" "" "${_ARG_CRON}"
					debug  "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
					LOG=0
				else
					debugn "info" "OK" "" "" "${_ARG_CRON}"
				fi
			fi
		fi
	fi

	# Logging still on?
	# Check for permissions
	if [ "${LOG}" = "1" ]; then
		if ! compare_chmod "$(permission "${LOGFILE}")" "${LOG_CHMOD}" > /dev/null 2>&1 ; then
			debug  "warn" "Logfile has wrong permissions: $(permission "${LOGFILE}"), should be: ${LOG_CHMOD}" "" "" "${_ARG_CRON}"
			debugi "info" "Trying to chmod to ${LOG_CHMOD}..." "" "" "${_ARG_CRON}"

			if ! chmod ${LOG_CHMOD} "${LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "" "" "${_ARG_CRON}"
				debug  "err"  "Failed to chmod ${LOG_CHMOD} ${LOGFILE}" "" "" "${_ARG_CRON}"
				debug  "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
				LOG=0
			else
				debugn "info" "OK" "" "" "${_ARG_CRON}"
			fi
		fi
	fi

	# Logging still on?
	# Check if it is writeable
	if [ "${LOG}" = "1" ]; then

		# Logfile not writeable
		if [ ! -w "${LOGFILE}" ]; then
			debug  "err"  "Logfile ${LOGFILE} not writeable. Check \$LOG_CHMOD value inf config." "" "" "${_ARG_CRON}"
			debug  "warn" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
			LOG=0
		fi
	fi

else
	debug "info" "(OPT) Logging disabled" "" "" "${_ARG_CRON}"
	LOG=0
fi

# Is logging still enabled after all checks?
# Write to the file
if [ "${LOG}" = "1" ]; then
	{
		echo;
		echo "--------------------------------------------------------------------------------";
		echo "$(date '+%Y-%m-%d') $(date '+%H:%M:%S') Starting";
	} >> "${LOGFILE}"
	debug "info" "Using config: ${CONFIG_FILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "(OPT) Logging enabled: ${LOGFILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
else
	debug "info" "Using config: ${CONFIG_FILE}" ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi



############################################################
# Command line arguments
############################################################
if [ "${_ARG_CRON}" = "1" ]; then
	debug "info" "Running in cron mode (--cron)." ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi
if [ "${_ARG_TEST}" = "1" ]; then
	debug "info" "Running tests only (--test)." ${LOG} "${LOGFILE}" "${_ARG_CRON}"
fi
#if [ "${_ARG_INFO}" = "1" ]; then
#	debug "info" "Showing information only (--info)."  ${LOG} "${LOGFILE}" "${_ARG_CRON}"
#fi


############################################################
# Destination Directory and Prefix
############################################################

# Check if CHMOD exists, otherwise use default values
if [ -z "${DUMP_DIR_CHMOD-}" ]; then
	debug "warn" "\$DUMP_DIR_CHMOD is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "Setting \$DUMP_DIR_CHMOD to ${_DEFAULT_DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
fi
if [ -z "${DUMP_FILE_CHMOD-}" ]; then
	debug "warn" "\$DUMP_FILE_CHMOD is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "Setting \$DUMP_FILE_CHMOD to ${_DEFAULT_DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_FILE_CHMOD}
fi
if ! valid_chmod "${DUMP_DIR_CHMOD}" > /dev/null 2>&1; then
	debug "err"  "Invalid chmod value for \$DUMP_DIR_CHMOD: ${DUMP_DIR_CHMOD} in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "Setting \$DUMP_DIR_CHMOD to ${_DEFAULT_DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
fi
if ! valid_chmod "${DUMP_FILE_CHMOD}" > /dev/null 2>&1; then
	debug "err"  "Invalid chmod value for \$DUMP_FILE_CHMOD: ${DUMP_FILE_CHMOD} in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "Setting \$DUMP_FILE_CHMOD to ${_DEFAULT_DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_FILE_CHMOD}
fi

# Check if destination dir exists
if [ -z "${DUMP_PATH-}" ]; then
	debug "err" "\$DUMP_PATH variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
elif [ ! -d "${DUMP_PATH}" ]; then
	debug  "warn" "Destination dir ${DUMP_PATH} does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "info" "Trying to create... " $LOG "${LOGFILE}" "${_ARG_CRON}"
	if ! mkdir -p "${DUMP_PATH}" > /dev/null 2>&1 ; then
		debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug  "info" "Adjusting file permissions to ${DUMP_DIR_CHMOD} on ${DUMP_PATH}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		chmod ${DUMP_DIR_CHMOD} "${DUMP_PATH}"
	fi
fi

# Check correct permissions of destination dir
if ! compare_chmod "$(permission "${DUMP_PATH}")" "${DUMP_DIR_CHMOD}" > /dev/null 2>&1 ; then
	debug  "err"  "Target directory has wrong permissions: $(permission "${DUMP_PATH}"), but should ${DUMP_DIR_CHMOD}." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "info" "Trying to chmod to ${DUMP_DIR_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}"

	if ! chmod "${DUMP_DIR_CHMOD}" "${DUMP_PATH}" > /dev/null 2>&1 ; then
		debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debugn "info" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
fi

# Check if destination dir is writeable
if [ ! -w "${DUMP_PATH}" ]; then
	debug  "err"  "Destination dir ${DUMP_PATH} is not writeable" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugi "err"  "Fix your configured permissions" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi

# Check output Prefix
if [ -z "${DUMP_FILE_PRE-}" ]; then
	debug "warn" "\$DUMP_FILE_PRE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "Using default 'date-time' prefix: ${_DEFAULT_DUMP_FILE_PRE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DUMP_FILE_PRE="${_DEFAULT_DUMP_FILE_PRE}"
fi



############################################################
# MySQL
############################################################

# Binaries do exist?
if ! command -v mysql > /dev/null 2>&1 ; then
	debug "err"  "'mysql' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 2
fi
if ! command -v mysqldump > /dev/null 2>&1 ; then
	debug "err"  "'mysqldump' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 2
fi

# Credentials file
if [ -z "${MYSQL_CNF_FILE-}" ]; then
	debug "err"  "\$MYSQL_CNF_FILE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi
if [ ! -f "${MYSQL_CNF_FILE}" ]; then
	debug "err"  "MySQL CNF file not found in ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi
if [ ! -r "${MYSQL_CNF_FILE}" ]; then
	debug "err"  "MySQL CNF file is not readable in ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi
if ! compare_chmod "$(permission "${MYSQL_CNF_FILE}")" "${_DEFAULT_MYSQL_CNF_CHMOD}" > /dev/null 2>&1 ; then
	debug "err"  "MySQL CNF file ${MYSQL_CNF_FILE} has dangerous permissions: $(permission "${MYSQL_CNF_FILE}")." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Fix it to ${_DEFAULT_MYSQL_CNF_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Note: If you are not alone on the machine, the password inside could have been compromised by now." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "If so, change your database password." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi

# SSL
if [ -z "${MYSQL_SSL_ENABLE-}" ]; then
	debug "err"  "\$MYSQL_SSL_ENABLE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "err"  "Aborting, as it is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 1
fi
if [  "${MYSQL_SSL_ENABLE}" = "1" ]; then
	if [ -z "${MYSQL_SSL_CA_PEM-}" ]; then
		debug "err"  "\$MYSQL_SSL_CA_PEM variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting, as you don't want clear-text connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	fi
	if [ ! -f "${MYSQL_SSL_CA_PEM}" ]; then
		debug "err"  "\$MYSQL_SSL_CA_PEM=\"$MYSQL_SSL_CA_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting, as you don't want clear-text connections." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	fi

	MYSQL_SSL_ARGS="--ssl-ca=${MYSQL_SSL_CA_PEM}"

	if [ -n "${MYSQL_SSL_CLIENT_CERT_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_CERT_PEM}" ]; then
			debug "err"  "\$MYSQL_SSL_CLIENT_CERT_PEM=\"$MYSQL_SSL_CLIENT_CERT_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 1
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-cert=${MYSQL_SSL_CLIENT_CERT_PEM}"
	fi
	if [ -n "${MYSQL_SSL_CLIENT_KEY_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_KEY_PEM}" ]; then
			debug "err"  "\$MYSQL_SSL_CLIENT_KEY_PEM=\"$MYSQL_SSL_CLIENT_KEY_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 1
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-key=${MYSQL_SSL_CLIENT_KEY_PEM}"
	fi

	debug "info" "(OPT) MySQL SSL connection enabled: ${MYSQL_SSL_ARGS}." $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	MYSQL_SSL_ENABLE=0
	MYSQL_SSL_ARGS=""
	debug "info" "(OPT) MySQL SSL connection disabled." $LOG "${LOGFILE}" "${_ARG_CRON}"
fi


# Testing MySQL connection
_CONN_ERR="$($(which mysql) --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" -e exit 2>&1)"
if [ "$?" != "0" ]; then
	debug  "err"  "Cannot connect to mysql database." $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "err"  "CMD: $(which mysql) --defaults-file=${MYSQL_CNF_FILE} ${MYSQL_SSL_ARGS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "err"  "SQL: ${_CONN_ERR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug  "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 3
else
	debug "info" "MySQL connection test successful." $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

# Testing MySQL for SSL connection
MYSQL_SSL_STATUS="$($(which mysql) --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" -e 'status;' 2>&1 | grep -E '^SSL:.*' | sed 's/SSL:\s*//g')"
if [ "${MYSQL_SSL_STATUS}" = "Not in use" ]; then
	if [ "${MYSQL_SSL_ENABLE}" = "1" ]; then
		debug "err"  "MySQL connection is not using SSL." $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 1
	else
		debug "info"  "MySQL connection is not using SSL." $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	debug "info" "MySQL connection is using SSL: ${MYSQL_SSL_STATUS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi




############################################################
# MySQL Dump Opts
############################################################
if [ -z "${MYSQL_OPTS-}" ]; then
	debug "info" "\$MYSQL_OPTS variable is not set or empty" $LOG "${LOGFILE}" "${_ARG_CRON}"
	MYSQL_OPTS=""
fi
debug "info"  "mysqldump options: ${MYSQL_OPTS}" $LOG "${LOGFILE}" "${_ARG_CRON}"


############################################################
# Bad MySQL Opts
############################################################
for opt in ${MYSQL_OPTS}; do
	for evil in ${MYSQL_EVIL_OPTS}; do
		if [ "${opt}" = "${evil}" ]; then
			debug "err"  "Insecure mysqldump option found in MYSQL_OPTS: '${evil}'" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 3
		fi
	done
	for bad in ${MYSQL_BAD_OPTS}; do
		if [ "${opt}" = "${evil}" ]; then
			debug "err"  "Disallowed mysqldump option found in MYSQL_OPTS: '${bad}'" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
			exit 3
		fi
	done
done



############################################################
# IGNORE/REQUIRE
############################################################
if [ -z "${IGNORE-}" ]; then
	debug "info" "\$IGNORE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "No database will be ignored" $LOG "${LOGFILE}" "${_ARG_CRON}"
	IGNORE=""
fi
if [ -z "${REQUIRE-}" ]; then
	debug "info" "\$REQUIRE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "info" "No database will explicitly be required" $LOG "${LOGFILE}" "${_ARG_CRON}"
	REQUIRE=""
fi



############################################################
# Compression
############################################################
if [ -z "${COMPRESS-}" ]; then
	debug "warn" "\$COMPRESS variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	COMPRESS=0
fi
if [ "${COMPRESS}" = "1" ]; then
	if [ -z "${COMPRESS_BIN-}" ]; then
		debug "err"  "\$COMPRESS_BIN variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi
	if [ -z "${COMPRESS_ARG-}" ]; then
		debug "info"  "\$COMPRESS_ARG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		COMPRESS_ARG=""
	fi
	if [ -z "${COMPRESS_EXT-}" ]; then
		debug "info"  "\$COMPRESS_EXT variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "info"  "Using 'compressed' as file extension." $LOG "${LOGFILE}" "${_ARG_CRON}"
		COMPRESS_EXT="compressed"
	fi

	if ! command -v "${COMPRESS_BIN}" > /dev/null 2>&1 ; then
		debug "warn" "${COMPRESS_BIN} not found. Fix \$COMPRESS_BIN" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	else
		debug "info" "(OPT) Compression enabled: Using ${COMPRESS_BIN} ${COMPRESS_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	debug "info" "(OPT) Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	COMPRESS="0"
fi



############################################################
# Encryption
############################################################
if [ -z "${ENCRYPT-}" ]; then
	debug "warn" "\$ENCRYPT variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Encryption disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	ENCRYPT=0
fi
if [ "${ENCRYPT}" = "1" ]; then
	if ! command -v openssl > /dev/null 2>&1 ; then
		debug "err"  "'openssl' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi
	if [ ! -f "${OPENSSL_PUBKEY_PEM}" ]; then
		debug "err"  "OpenSSL pubkey not found in ${OPENSSL_PUBKEY_PEM}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi
	if [ -z "${OPENSSL_ALGO_ARG-}" ]; then
		debug "warn" "\$OPENSSL_ALGO_ARG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Encryption defaults to: ${OPENSSL_ALGO_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		OPENSSL_ALGO_ARG="${_DEFAULT_OPENSSL_ALGO_ARG}"
	fi
	# Test openssl Algo
	if ! echo "test" | $(which openssl) smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} "${OPENSSL_PUBKEY_PEM}" > /dev/null 2>&1 ; then
		debug "err"  "openssl encryption test failed. Validate \$OPENSSL_ALGO_ARG" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "err"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}"
		exit 2
	fi

	debug "info" "(OPT) Encryption enabled" $LOG "${LOGFILE}" "${_ARG_CRON}"

else
	debug "info" "(OPT) Encryption disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	ENCRYPT="0"
fi



############################################################
# Deletion
############################################################
if [ -z "${DELETE-}" ]; then
	debug "warn" "\$DELETE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	DELETE=0
fi
if [ "${DELETE}" = "1"  ]; then
	if [ -z "${DELETE_METHOD-}" ]; then
		debug "warn" "\$DELETE_METHOD variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" = "tmpwatch" ] &&  ! command -v tmpwatch > /dev/null 2>&1 ; then
		debug "warn" "'tmpwatch' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" = "tmpreaper" ] && ! command -v tmpreaper > /dev/null 2>&1 ; then
		debug "warn" "'tmpreaper' not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ "${DELETE_METHOD}" != "tmpwatch" ] && [ "${DELETE_METHOD}" != 'tmpreaper' ]; then
		debug "warn" "\$DELETE_METHOD must be either 'tmpwatch' or 'tmpreaper' in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif [ -z "${DELETE_IF_OLDER-}" ]; then
		debug "warn" "\$DELETE_IF_OLDER variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	elif ! valid_tmpwatch "${DELETE_IF_OLDER}" > /dev/null 2>&1 ; then
		debug "warn" "\$DELETE_IF_OLDER does not have a valid ${DELETE_METHOD} value: ${DELETE_IF_OLDER} (See: man ${DELETE_METHOD})" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Deletion of old files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE=0
	else
		debug "info" "(OPT) Deletion enabled. Deleting files older than $(get_tmpwatch_value "${DELETE_IF_OLDER}") $(get_tmpwatch_unit_name "${DELETE_IF_OLDER}"). Using: ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	debug "info" "(OPT) Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
fi

# Check for forced deletion
if [ "${DELETE}" = "1" ]; then
	if [ -z "${DELETE_FORCE-}" ]; then
		debug "warn" "\$DELETE_FORCE variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	elif ! isint "${DELETE_FORCE}" > /dev/null 2>&1 ; then
		debug "warn" "\$DELETE_FORCE variable is not a valid integer" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	elif [ "${DELETE_FORCE}" != "0" ] && [ "${DELETE_FORCE}" != "1" ]; then
		debug "warn" "\$DELETE_FORCE variable invalid. Must be either 0 or 1." $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}"
		DELETE_FORCE=0
	fi


	if [ "${DELETE_FORCE}" = 1 ]; then
		debug "info" "${DELETE_METHOD}: Using '--force' option for ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	else
		debug "info" "${DELETE_METHOD}: Not forcing (--force) deletion on read-only files for ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	fi
else
	DELETE="0"
fi



############################################################
# Nagios
############################################################
if [ -z "${NAGIOS_LOG-}" ]; then
	debug "warn" "\$NAGIOS_LOG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	NAGIOS_LOG=0
elif [ "${NAGIOS_LOG}" = "1"  ]; then

	# Checking chmod variable
	if [ -z "${NAGIOS_LOG_CHMOD-}" ]; then
		debug "warn" "\$NAGIOS_LOG_CHMOD variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
	elif ! valid_chmod "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1; then
		debug "err"  "Invalid chmod value for \$NAGIOS_LOG_CHMOD: ${NAGIOS_LOG_CHMOD} in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "info" "Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
	fi

	# Checking logfile variable
	if [ -z "${NAGIOS_LOGFILE-}" ]; then
		debug "warn" "\$NAGIOS_LOG variable is not set or empty in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
		NAGIOS_LOG=0
	# Check if file exists
	elif [ ! -f "${NAGIOS_LOGFILE}" ]; then
		debug  "warn" "${NAGIOS_LOGFILE} not found" $LOG "${LOGFILE}" "${_ARG_CRON}"
		debugi "info" "Trying to create..." $LOG "${LOGFILE}" "${_ARG_CRON}"

		if ! touch "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "err"  "Failed to create file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "info" "Created file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debugi "info" "Trying to chmod to ${NAGIOS_LOG_CHMOD}..." $LOG "${LOGFILE}" "${_ARG_CRON}"

			if ! chmod ${NAGIOS_LOG_CHMOD} "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug  "err"  "Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
				NAGIOS_LOG=0
			else
				debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
			fi
		fi
	# Check if it has wrong permissions
	elif ! compare_chmod "$(permission "${NAGIOS_LOGFILE}")" "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1 ; then
		debug  "warn" "Nagios logfile has wrong permissions: $(permission "${NAGIOS_LOGFILE}"), but should be: ${NAGIOS_LOG_CHMOD} " $LOG "${LOGFILE}" "${_ARG_CRON}"
		debugi "info" "Trying to chmod to ${NAGIOS_LOG_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}"
		if ! chmod "${NAGIOS_LOG_CHMOD}" "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "err"  "Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug  "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debugn "info" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}"
		fi
	fi

	# Still enabled?
	if [ "${NAGIOS_LOG}" = "1"  ]; then
		if [ ! -r "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "${NAGIOS_LOGFILE} not readable. Fix CHMOD permissions in config." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		elif [ ! -w "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "${NAGIOS_LOGFILE} not writeable. Fix CHMOD permissions in config." $LOG "${LOGFILE}" "${_ARG_CRON}"
			debug "warn" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
			NAGIOS_LOG=0
		else
			debug "info" "(OPT) Nagios plugin log enabled: ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}"
		fi
	fi

else
	debug "info" "(OPT) Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}"
	NAGIOS_LOG="0"
fi



############################################################
# Print additional information
############################################################

debug "info" "Backup directory: ${DUMP_PATH}" $LOG "${LOGFILE}" "${_ARG_CRON}"



############################################################
# Test mode
############################################################
if [ "${_ARG_TEST}" = "1" ]; then
	debug "info" "Exiting program from test mode (--test)."  ${LOG} "${LOGFILE}" "${_ARG_CRON}"
	exit 0
fi


################################################################################
#
# ENTRY POINT: MAIN
#
################################################################################

# Binaries
MYSQL="$(which mysql)"
MYSQLDUMP="$(which mysqldump)"
OPENSSL="$(which openssl)"
TMPWATCH="$(which "${DELETE_METHOD}")"	# This can be tmpwatch or tmpreaper

# Error code for nagios
ERROR=0



############################################################
# Create tmp files and folders
############################################################
MY_TMP_DIR="$( mktemp -d /tmp/mysqldump-secure.XXXXXXXXXX )"
MY_TMP_FILE_DUMP="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" )"
MY_TMP_FILE_COMP="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" )"
MY_TMP_FILE_ENCR="$( mktemp "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" )"



############################################################
# Get all databases
############################################################

# Get a list of all databases
debugi "info" "Retrieving list of databases... " $LOG "${LOGFILE}" "${_ARG_CRON}"

# gets all databases (even empty ones)
DATABASES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --batch -e 'show databases;' | sed 1d )"
# Only gets databases which have content (tables)
#DATABASES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --no-auto-rehash --skip-column-names -e 'SELECT DISTINCT table_schema FROM information_schema.tables;')"

NUM_DB="$(echo "${DATABASES}" | wc -l | tr -d ' ')"
debugn "info" "${NUM_DB}" $LOG "${LOGFILE}" "${_ARG_CRON}"



############################################################
# Dump databases
############################################################

TOTAL_STARTTIME=$(date +%s)
TOTAL_SIZE=0
TOTAL_DBS=0
TOTAL_IGN=0
TOTAL_ERR=0

# Get info for nagios log
NAGIOS_DB_DUMPED=""
NAGIOS_DB_IGNORED=""
NAGIOS_DB_ERROR=""


for db in ${DATABASES}; do

	# Reset skip flag
	skip=0

	# If a database does not show up in information_schema.tables, it means it
	# has no tables yet and is therefore empty.
	EMPTY="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --batch \
		-e "SELECT IF(COUNT(*) = 0, 'yes', 'no') AS empty
			FROM INFORMATION_SCHEMA.TABLES
			WHERE TABLE_SCHEMA = '${db}';" | tail -n1 )"

	if [ "${EMPTY}" = "yes" ]; then
		skip=1
	fi

	# Skip databases that are scheduled for skipping in config
	for ign_db in ${IGNORE}; do
		if [ "${ign_db}" = "${db}" ]; then
			skip=2
		fi
	done


	if [ ${skip} -eq 0 ]; then

		# Get file extension
		if [ ${COMPRESS} -eq 1 ]; then
			if [ ${ENCRYPT} -eq 1 ]; then
				ext=".sql.${COMPRESS_EXT}.enc"
			else
				ext=".sql.${COMPRESS_EXT}"
			fi
		else
			if [ ${ENCRYPT} -eq 1 ]; then
				ext=".sql.enc"
			else
				ext=".sql"
			fi
		fi


		# File already exists on disk?
		if [ -f "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" ]; then

			# Increment total dbs error count
			TOTAL_ERR=$((TOTAL_ERR + 1))

			# Add failed db to nagios log
			[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"

			debug "err"  "${db} cannot be written to disk (file exists: ${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext})" $LOG "${LOGFILE}" "${_ARG_CRON}"
			ERROR="$(merge_exit_codes "${ERROR}" 2)"

		# All Good, file can be written
		else

			# Check required databases
			for req in ${REQUIRE}; do
				# Required database found?
				# Remove from variable
				if [ "${db}" = "${req}" ]; then
					REQUIRE="$( echo "${REQUIRE}" | sed "s/${db}//" )"
				fi
			done

			DB_SIZE="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --batch \
				-e "SELECT SUM(ROUND(((DATA_LENGTH + INDEX_LENGTH ) / 1024 / 1024),2)) AS Size
					FROM INFORMATION_SCHEMA.TABLES
					WHERE TABLE_SCHEMA = '${db}';" | tail -n1 )"

			TOTAL_SIZE=$( sum "${TOTAL_SIZE}" "${DB_SIZE}" )
			starttime=$(date +%s)

			if [ ${COMPRESS} -eq 1 ]; then
				if [ ${ENCRYPT} -eq 1 ]; then
					ext=".sql.${COMPRESS_EXT}.enc"
					debugi "info"  "Dumping:  ${db} (${DB_SIZE} MB) (compressed) (encrypted) " $LOG "${LOGFILE}" "${_ARG_CRON}"

					# execute with POSIX pipestatus emulation (needs to get rid of shellcheck)
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";
					exec 4>&1
					# shellcheck disable=SC2086
					error_statuses="$( (
						(${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}" || echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" && echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3) |
						(${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}" || echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" && echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3) |
						(${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}" || echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" && echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3)
					) 3>&1 >&4)"
					exec 4>&-

				else
					ext=".sql.${COMPRESS_EXT}"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) (compressed) " $LOG "${LOGFILE}" "${_ARG_CRON}"

					# execute with POSIX pipestatus emulation (needs to get rid of shellcheck)
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")"
					exec 4>&1
					# shellcheck disable=SC2086
					error_statuses="$( (
						(${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}" || echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" && echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3) |
						(${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}" > "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" || echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" && echo "1:$?:$(cat "${MY_TMP_FILE_COMP}")" >&3)
					) 3>&1 >&4)"
					exec 4>&-

				fi
			else
				if [ ${ENCRYPT} -eq 1 ]; then
					ext=".sql.enc"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) (encrypted) " $LOG "${LOGFILE}" "${_ARG_CRON}"

					# execute with POSIX pipestatus emulation (needs to get rid of shellcheck)
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";
					exec 4>&1
					# shellcheck disable=SC2086
					error_statuses="$( (
						(${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}" || echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" && echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3) |
						(${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}" || echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" && echo "2:$?:$(cat "${MY_TMP_FILE_ENCR}")" >&3)
					) 3>&1 >&4)"
					exec 4>&-

				else
					ext=".sql"
					debugi "info" "Dumping:  ${db} (${DB_SIZE} MB) " $LOG "${LOGFILE}" "${_ARG_CRON}"

					# execute with POSIX pipestatus emulation (needs to get rid of shellcheck)
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";
					exec 4>&1
					# shellcheck disable=SC2086
					error_statuses="$( (
						(${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} "${db}" 2> "${MY_TMP_FILE_DUMP}" > "${DUMP_PATH}/${DUMP_FILE_PRE}${db}${ext}" || echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" && echo "0:$?:$(cat "${MY_TMP_FILE_DUMP}")" >&3)
					) 3>&1 >&4)"
					exec 4>&-

				fi
			fi


			# Error Checking
			#
			# Inside $error_statuses we have the following information.
			# Note: Not all lines must be there (depends on enabled options)
			#
			# "0:<exit code>:<stderr msg>"   <--mysqldump
			# "1:<exit code>:<stderr msg>"   <--compression
			# "2:<exit code>:<stderr msg>"   <--openssl
			#
			# Cases:
			#  1. Error code == 0 and <stderr msg> empty      => OK
			#  2. Error code == 0 and <stderr msg> not empty  => Warning
			#  3. Error code != 0                             => Error
			MY_ERRORS=""
			MY_WARNINGS=""

			IFS='
			'
			for _err in ${error_statuses}; do
				_type="$( echo "${_err}" | awk -F ':' '{print $1}' )"
				_exit="$( echo "${_err}" | awk -F ':' '{print $2}' )"
				_msg="$(  echo "${_err}" | awk -F ':' '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )"

				if [ "${_type}" = "0" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="mysqldump: ${_msg}" || MY_ERRORS="${MY_ERRORS}\nmysqldump: ${_msg}"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="mysqldump: ${_msg}" || MY_WARNINGS="${MY_WARNINGS}\nmysqldump: ${_msg}"
					fi
				elif [ "${_type}" = "1" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="compression: ${_msg}" || MY_ERRORS="${MY_ERRORS}\ncompression: ${_msg}"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="compression: ${_msg}" || MY_WARNINGS="${MY_WARNINGS}\ncompression: ${_msg}"
					fi
				elif [ "${_type}" = "2" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="encryption: ${_msg}" || MY_ERRORS="${MY_ERRORS}\nencryption: ${_msg}"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="encryption: ${_msg}" || MY_WARNINGS="${MY_WARNINGS}\nencryption: ${_msg}"
					fi
				fi
			done
			unset IFS



			# Error Evaluation
			#
			if [ "${MY_ERRORS}" != "" ]; then
				TOTAL_ERR=$((TOTAL_ERR + 1))
				debug_nl "info" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debug "err" "Error dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				debugr "err" "${MY_ERRORS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				ERROR="$(merge_exit_codes "${ERROR}" 2)"
				[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"
			else
				TOTAL_DBS=$((TOTAL_DBS + 1))
				endtime=$(date +%s)
				debugn "info" "$((endtime - starttime)) sec" $LOG "${LOGFILE}" "${_ARG_CRON}"

				[ "${NAGIOS_DB_DUMPED}" = "" ] && NAGIOS_DB_DUMPED="${db}" || NAGIOS_DB_DUMPED="${NAGIOS_DB_DUMPED},${db}"

				if [ "${MY_WARNINGS}" != "" ]; then
					debug  "warn" "Warning dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}"
					debugr "warn" "${MY_WARNINGS}" $LOG "${LOGFILE}" "${_ARG_CRON}"
				fi
			fi


			# Debug output.
			# TODO: add --debug flag and remove '1'
			debugr "debug" "${error_statuses}" $LOG "${LOGFILE}" "${_ARG_CRON}" 1

		fi

	elif [ ${skip} -eq 1 ]; then
		debug "info" "Skipping: ${db} (DB is empty)" $LOG "${LOGFILE}" "${_ARG_CRON}"
		TOTAL_IGN=$((TOTAL_IGN + 1))
		[ "${NAGIOS_DB_IGNORED}" = "" ] && NAGIOS_DB_IGNORED="${db}" || NAGIOS_DB_IGNORED="${NAGIOS_DB_IGNORED},${db}"
	else
		debug "info" "Skipping: ${db} (IGNORE=\"${db}\" in config)" $LOG "${LOGFILE}" "${_ARG_CRON}"
		TOTAL_IGN=$((TOTAL_IGN + 1))
		[ "${NAGIOS_DB_IGNORED}" = "" ] && NAGIOS_DB_IGNORED="${db}" || NAGIOS_DB_IGNORED="${NAGIOS_DB_IGNORED},${db}"
	fi

done
TOTAL_ENDTIME=$(date +%s)


for req in ${REQUIRE}; do
	debug "err"  "Required database: \"${req}\" has not been dumped." $LOG "${LOGFILE}" "${_ARG_CRON}"
	ERROR="$(merge_exit_codes "${ERROR}" 2)"
done


debug "info" "Dumping finished (OK: ${TOTAL_DBS} dbs, IGN: ${TOTAL_IGN} dbs, ERR: ${TOTAL_ERR}, TOTAL: ${NUM_DB})" $LOG "${LOGFILE}" "${_ARG_CRON}"
debug "info" "Took $((TOTAL_ENDTIME - TOTAL_STARTTIME)) seconds" $LOG "${LOGFILE}" "${_ARG_CRON}"
debug "info" "Total size dumped: ${TOTAL_SIZE} MB" $LOG "${LOGFILE}" "${_ARG_CRON}"





############################################################
# Delete old Files
############################################################
if [ ${DELETE} -eq 1 ]; then

	# Force deletion?
	[ "${DELETE_FORCE}" = "1" ] && FORCE_ARG="--force" || FORCE_ARG=""

	DELETED="$(${TMPWATCH} ${FORCE_ARG} -m "$DELETE_IF_OLDER" -v "${DUMP_PATH}/")"
	if [ $? -ne 0 ]; then
		ERROR="$(merge_exit_codes "${ERROR}" 1)"
	fi
	NUM_DEL="$( echo "${DELETED}" | grep -ci 'Removing' )"
	debug  "info" "Deleting files older than ${DELETE_IF_OLDER} hours... ${NUM_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}"
	debugr "info" "${DELETED}" $LOG "${LOGFILE}" "${_ARG_CRON}"
else
	NUM_DEL="0"
fi



############################################################
# Nagios Plugin Log
############################################################
if [ "${NAGIOS_LOG}" = "1" ]; then
	debug "info" "Writing nagios logfile" $LOG "${LOGFILE}" "${_ARG_CRON}"

	{
		echo "[state]";
		echo "success = ${ERROR}";
		echo "lastbak = ${TOTAL_STARTTIME}";
		echo "message = ";
		echo "missing = ${REQUIRE}";
		echo;
		echo "[options]";
		echo "opt_log = ${LOG}";
		echo "opt_com = ${COMPRESS}";
		echo "opt_enc = ${ENCRYPT}";
		echo "opt_del = ${DELETE}";
		echo;
		echo "[messages]";
		echo "msg_dbs = ${TOTAL_DBS}";
		echo "msg_ign = ${TOTAL_IGN}";
		echo "msg_err = ${TOTAL_ERR}";
		echo "msg_meg = ${TOTAL_SIZE}";
		echo "msg_sec = $((TOTAL_ENDTIME - TOTAL_STARTTIME))";
		echo "msg_del = ${NUM_DEL}";
		echo;
		echo "[tmpwatch]";
	} > "${NAGIOS_LOGFILE}"

	if [ "${DELETE}" = "1" ]; then
		echo "del_time = ${DELETE_IF_OLDER}" >> "${NAGIOS_LOGFILE}"
	else
		echo "del_time = 0"	>> "${NAGIOS_LOGFILE}"
	fi

	{
		echo "[stats]";
		echo "db_dumped = ${NAGIOS_DB_DUMPED}";
		echo "db_error = ${NAGIOS_DB_ERROR}";
		echo "db_ignored = ${NAGIOS_DB_IGNORED}"
	} >> "${NAGIOS_LOGFILE}"

fi


############################################################
# Delete temporary files
############################################################

rm "${MY_TMP_FILE_DUMP}" 2>/dev/null || debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
rm "${MY_TMP_FILE_COMP}" 2>/dev/null || debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}"
rm "${MY_TMP_FILE_ENCR}" 2>/dev/null || debug "warn"  "Cannot delete tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}"
rm -rf "${MY_TMP_DIR}"   2>/dev/null || debug "warn"  "Cannot delete tmp dir: ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}"



############################################################
# Exit
############################################################

if [ "${ERROR}" != "0" ]; then
	# Send bad exit code
	debug "err"  "[FAIL] Finished with errors" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 4
else
	# Send good exit code
	debug "info" "[OK] Finished successfully" $LOG "${LOGFILE}" "${_ARG_CRON}"
	exit 0
fi
