#!/bin/sh -u
#
# -u: nounset (enable: set -u | disable: set +u)
# -e: errexit
# -r: restricted
#
#
# VARIABLE CONVENTIONS
#
# 1. Function variables
# ----------------------
# * Lowercase
# * Prefixed with _
# Example: _tmp, _dir, _len
#
# 2. Config file variables
# ------------------------
# * Uppercase
# * No prefix
# Example: MYSQL_OPTS
#
# 3. Default values for config file variables
# -------------------------------------------
# * Uppercase
# * Prefixed with _DEFAULT_
# * Same name as config file variables
# Example: _DEFAULT_CONFIG_FILE
#
# 4. Global program variables
# -------------------------------------------
# * Uppercase
# * Prefixed with MDS_[SECTION]_
# Example: MDS_INFO_NAME, MDS_MYSQL_xxx, MDS_COUNT_WARNINGS
#
# 5. Temporary variables
# -------------------------------------------
# * Uppercase
# * Prefixed with _TMP
# Example: _TMP_RESULT



# Don't screw with numbers, sorting, date etc
LC_ALL=C



####################################################################################################
####################################################################################################
##
## GLOBAL VARIABLES
##
####################################################################################################
####################################################################################################


################################################################################
#
# VERSION / CREDITS
#
################################################################################

#
# Some of this data is also written to the nagios logfile
# in order to be able to check against latest/desired mysqldump-secure version.
#
INFO_NAME="mysqldump-secure"
INFO_AUTHOR="Patrick Plocke <patrick@plocke.de>"
INFO_GPGKEY="0x28BF179F"
INFO_LICENSE="MIT"
INFO_URL="http://mysqldump-secure.org"
INFO_REPO="https://github.com/cytopia/mysqldump-secure"
INFO_DATE="2016-03-14"
INFO_VERSION="0.16"



################################################################################
#
# AUTO-GENERATED
#
################################################################################

# The following are auto-generated variables by the installer.
# to determine where the script and its config files are installed.
_PREFIX_ETC=""
#_PREFIX_BIN=""
#_PREFIX_LOG=""




############################################################
# Exit codes
############################################################

# Everything went fine.
# No errors and no warnings.
EXIT_OK=0

# The database dump was successful, but some other
# warnings occured.
# E.g.: tmpreaper/tmpwatch could not delete files, etc
EXIT_WARNING=1

# The database dump was successful, but some other
# errors occured.
# E.g.: Directories could not be created, etc
EXIT_ERROR=2

# The database dump had errors.
# E.g.: File already existed, wrong mysqldump options, wrong compression options, etc
EXIT_FAIL=3

# The program terminated before it could do backups
# E.g.: No database connection, wrong config settings, etc
EXIT_ABORT=4





############################################################
# Warning/Error/Fail count
############################################################

#
# How many warnings occured
#
MDS_WARNING_COUNT=0

#
# How many errors occured
#
MDS_ERROR_COUNT=0


#
# How many failed database dumps occured
#
MDS_FAIL_COUNT=0




################################################################################
#
# DEFAULT VARIABLES
#
################################################################################

#
# Do not djust the following default variables!
# They can be overwritten inside mysqldump-secure.conf
# or via command line arguments
#

# Default Configuration Path/Name
_DEFAULT_CONFIG_FILE="${_PREFIX_ETC}/etc/mysqldump-secure.conf"
_DEFAULT_CONFIG_CHMOD="0400"

# Default output Variables
_DEFAULT_DUMP_DIR="${_PREFIX_ETC}/var/mysqldump-secure"
_DEFAULT_DUMP_DIR_CHMOD="0700"

_DEFAULT_DUMP_FILE_PRE="$(date '+%Y-%m-%d')_$(date '+%H-%M')__"
_DEFAULT_DUMP_FILE_CHMOD="0400"


# MySQL defaults
_DEFAULT_MYSQL_CNF_CHMOD="0400"

# Default minimum size (in MB) required to enable `--quick`
_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE=200

# Default OpenSSL Variables
_DEFAULT_OPENSSL_ALGO_ARG="-aes256"

# Logging defaults
_DEFAULT_LOG_CHMOD="0600"
_DEFAULT_LOGFILE="${_PREFIX_ETC}/var/log/mysqldump-secure.log"

# Default nagios variables
_DEFAULT_NAGIOS_LOG_CHMOD="0644"

# Default system temp directory
_DEFAULT_TMP_DIR="/tmp"



################################################################################
#
# MYSQL VARIABLES
#
################################################################################


# These command line arguments are considered insecure and can lead
# to compromising your data
MYSQL_EVIL_OPTS="--password -p --port -P --user -u --host -h --socket -s"

# Do not allow to read any other MySQL configuration file
# than the one specified in the configuration.
MYSQL_BAD_OPTS="--no-defaults --defaults-extra-file --defaults-file"
# All SSL Options are done via configuration
MYSQL_BAD_OPTS="${MYSQL_BAD_OPTS} --ssl --ssl-ca --ssl-cert --ssl-key"
# All Transaction Options (Consistency) are done via configuration
MYSQL_BAD_OPTS="${MYSQL_BAD_OPTS} --single-transaction --lock-tables --skip-lock-tables"
# Handled conditionally
MYSQL_BAD_OPTS="${MYSQL_BAD_OPTS} --quick -q --skip-quick"



################################################################################
#
# T E R M I N A L   C O L O R S
#
################################################################################

# If having a tty (console) use colors
if [ -t 1 ]; then
	CLR_OK="$(tput setf 2 2>/dev/null || tput setaf 2 2>/dev/null)"
	CLR_FATAL="$(tput setf 4 2>/dev/null || tput setaf 1 2>/dev/null)"
	CLR_ERROR="$(tput setf 4 2>/dev/null || tput setaf 1 2>/dev/null)"
	CLR_WARNING="$(tput setf 6 2>/dev/null || tput setaf 3 2>/dev/null)"
	CLR_DEBUG="$(tput setf 0 2>/dev/null || tput setaf 248 2>/dev/null)"
	CLR_TRACE="$(tput setf 0 2>/dev/null || tput setaf 242 2>/dev/null)"
	CLR_RESET="$(tput sgr0 2>/dev/null)"
# Dump terminal (e.g.: via cron)
else
	CLR_OK=""
	CLR_FATAL=""
	CLR_ERROR=""
	CLR_WARNING=""
	CLR_DEBUG=""
	CLR_TRACE=""
	CLR_RESET=""
fi






####################################################################################################
####################################################################################################
##
## GLOBAL FUNCTIONS
##
####################################################################################################
####################################################################################################



################################################################################
#
#  F U N C T I O N S
#
################################################################################

############################################################
# Logger functions
############################################################

# Output to stdout/stderr and to file (with newline).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debug() {
	_lvl="${1}"		# Loglevel: "trace", "debug", "info", "warn" or "err" "fatal"
	_msg="${2}"		# message to output
	_log="${3}"		# (0|1) log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# (0|1) run for cron?
	_debug="${6}"	# (0|1|2) run in debug (and trace) mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		[ "${_lvl}" = "ok" ]   && printf "${CLR_OK}[OK]    %s\n${CLR_RESET}" "${_msg}"
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s\n" "${_msg}"

		# Show debug/trace output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" = "2" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${_msg}"
			[ "${_lvl}" = "trace" ] && printf "${CLR_TRACE}[TRACE] %s\n${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" != "0" ]; then
			echo "${_msg}"
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi


	# Always show warn, error and fatal
	[ "${_lvl}" = "warn"  ] && printf "${CLR_WARNING}[WARN]  %s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"   ] && printf "${CLR_ERROR}[ERR]   %s\n${CLR_RESET}" "${_msg}" 1>&2		# stdout -> stderr
	[ "${_lvl}" = "fatal" ] && printf "${CLR_FATAL}[FATAL] %s\n${CLR_RESET}" "${_msg}" 1>&2		# stdout -> stderr


	# Log to file
	_pre=""
	[ "${_lvl}" = "trace" ] && _pre="[TRACE]"
	[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
	[ "${_lvl}" = "info"  ] && _pre="[INFO] "
	[ "${_lvl}" = "ok"    ] && _pre="[OK]   "
	[ "${_lvl}" = "warn"  ] && _pre="[WARN] "
	[ "${_lvl}" = "err"   ] && _pre="[ERR]  "
	[ "${_lvl}" = "fatal" ] && _pre="[FATAL]"

	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" != "0" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}


# Output to stdout/stderr and to file (with multiple lines).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debugr() {
	_lvl="${1}"		# Loglevel: "trace", "debug", "info", "warn" or "err" "fatal"
	_msg="${2}"		# message to output
	_log="${3}"		# (0|1) log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# (0|1) run for cron?
	_debug="${6}"	# (0|1|2) run in debug (and trace) mode?

	# [INFO]/[DEBUG] Hide info/debug output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		# [OK]
		if [ "${_lvl}" = "ok" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "${CLR_OK}[OK]    %s\n${CLR_RESET}" "${line}"
			done
			unset IFS
		fi
		# [INFO]
		if [ "${_lvl}" = "info" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "[INFO]  %s\n" "${line}"
			done
			unset IFS
		fi

		# [DEBUG] Show debug output?
		if [ "${_debug}" = "1" ]; then
			if [ "${_lvl}" = "debug" ]; then
				IFS='
				'
				for line in ${_msg}; do
					printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${line}"
				done
				unset IFS
			fi
		# [TRACE]/[DEBUG] Show debug output?
		elif [ "${_debug}" = "2" ]; then
			if [ "${_lvl}" = "debug" ]; then
				IFS='
				'
				for line in ${_msg}; do
					printf "${CLR_DEBUG}[DEBUG] %s\n${CLR_RESET}" "${line}"
				done
				unset IFS
			fi
			if [ "${_lvl}" = "trace" ]; then
				IFS='
				'
				for line in ${_msg}; do
					printf "${CLR_TRACE}[TRACE] %s\n${CLR_RESET}" "${line}"
				done
				unset IFS
			fi
		elif [ "${_debug}" != "0" ]; then
			echo "${_msg}"
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi



	# [WARN] Always show warn
	if [ "${_lvl}" = "warn" ]; then
		IFS='
		'
		for line in ${_msg}; do
			printf "${CLR_WARNING}[WARN]  %s\n${CLR_RESET}" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
	fi

	# [ERR] Always show error
	if [ "${_lvl}" = "err" ]; then
		IFS='
		'
		for line in ${_msg}; do
			printf "${CLR_ERROR}[ERR]   %s\n${CLR_RESET}" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
	fi

	# [FATAL] Always show fatal
	if [ "${_lvl}" = "fatal" ]; then
		IFS='
		'
		for line in ${_msg}; do
			printf "${CLR_FATAL}[FATAL] %s\n${CLR_RESET}" "${line}" 1>&2	# stdout -> stderr
		done
		unset IFS
	fi



	# Log to file
	_pre=""
	[ "${_lvl}" = "trace" ] && _pre="[TRACE]"
	[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
	[ "${_lvl}" = "ok"    ] && _pre="[OK]   "
	[ "${_lvl}" = "info"  ] && _pre="[INFO] "
	[ "${_lvl}" = "warn"  ] && _pre="[WARN] "
	[ "${_lvl}" = "err"   ] && _pre="[ERR]  "
	[ "${_lvl}" = "fatal" ] && _pre="[FATAL]"


	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${line}" >> "${_file}"
			done
			unset IFS
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${line}" >> "${_file}"
			done
			unset IFS
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			IFS='
			'
			for line in ${_msg}; do
				printf "%s %s %s %s\n" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${line}" >> "${_file}"
			done
			unset IFS
		fi
	elif [ "${_log}" != "0" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}


# Inline Output to stdout/stderr and to file (no newline).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debugi() {
	_lvl="${1}"		# Loglevel: "trace", "debug", "info", "warn" or "err" "fatal"
	_msg="${2}"		# message to output
	_log="${3}"		# (0|1) log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# (0|1) run for cron?
	_debug="${6}"	# (0|1|2) run in debug (and trace) mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		[ "${_lvl}" = "ok" ]   && printf "${CLR_OK}[OK]    %s${CLR_RESET}" "${_msg}"
		[ "${_lvl}" = "info" ] && printf "[INFO]  %s" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}[DEBUG] %s${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" = "2" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}[DEBUG] %s${CLR_RESET}" "${_msg}"
			[ "${_lvl}" = "trace" ] && printf "${CLR_TRACE}[TRACE] %s${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" != "0" ]; then
			echo "${_msg}"
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi


	# Always show warn, error and fatal
	[ "${_lvl}" = "warn"  ] && printf "${CLR_WARNING}[WARN]  %s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"   ] && printf "${CLR_ERROR}[ERR]   %s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "fatal" ] && printf "${CLR_FATAL}[FATAL] %s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr


	# Log to file
	_pre=""
	[ "${_lvl}" = "trace" ] && _pre="[TRACE]"
	[ "${_lvl}" = "debug" ] && _pre="[DEBUG]"
	[ "${_lvl}" = "info"  ] && _pre="[INFO] "
	[ "${_lvl}" = "warn"  ] && _pre="[WARN] "
	[ "${_lvl}" = "err"   ] && _pre="[ERR]  "
	[ "${_lvl}" = "fatal" ] && _pre="[FATAL]"

	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			printf "%s %s %s %s" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			printf "%s %s %s %s" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			printf "%s %s %s %s" "$(date '+%Y-%m-%d')" "$(date '+%H:%M:%S')" "${_pre}" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" != "0" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}

# Output to stdout/stderr and to file (No date output).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debugn() {
	_lvl="${1}"		# Loglevel: "trace", "debug", "info", "warn" or "err" "fatal"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6}"	# run in debug mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		[ "${_lvl}" = "ok" ]   && printf "${CLR_OK}%s\n${CLR_RESET}" "${_msg}"
		[ "${_lvl}" = "info" ] && printf "%s\n" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}%s\n${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" = "2" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}%s\n${CLR_RESET}" "${_msg}"
			[ "${_lvl}" = "trace" ] && printf "${CLR_TRACE}%s\n${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" != "0" ]; then
			echo "${_msg}"
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi


	# Always show warn, error and fatal
	[ "${_lvl}" = "warn"  ] && printf "${CLR_WARNING}%s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"   ] && printf "${CLR_ERROR}%s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "fatal" ] && printf "${CLR_FATAL}%s\n${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr

	# Log to file
	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			printf "%s\n" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			printf "%s\n" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			printf "%s\n" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" != "0" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}


# Output to stdout/stderr and to file (No date output, No newline).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debugni() {
	_lvl="${1}"		# Loglevel: "trace", "debug", "info", "warn" or "err" "fatal"
	_msg="${2}"		# message to output
	_log="${3}"		# log to file?
	_file="${4}"	# full path to logfile
	_cron="${5}"	# run for cron?
	_debug="${6}"	# run in debug mode?

	# Hide info/debug output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		[ "${_lvl}" = "ok" ]   && printf "${CLR_OK}%s${CLR_RESET}" "${_msg}"
		[ "${_lvl}" = "info" ] && printf "%s" "${_msg}"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}%s${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" = "2" ]; then
			[ "${_lvl}" = "debug" ] && printf "${CLR_DEBUG}%s${CLR_RESET}" "${_msg}"
			[ "${_lvl}" = "trace" ] && printf "${CLR_TRACE}%s${CLR_RESET}" "${_msg}"
		elif [ "${_debug}" != "0" ]; then
			echo "${_msg}"
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi


	# Always show warn, error and fatal
	[ "${_lvl}" = "warn"  ] && printf "${CLR_WARNING}%s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"   ] && printf "${CLR_ERROR}%s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "fatal" ] && printf "${CLR_FATAL}%s${CLR_RESET}" "${_msg}" 1>&2	# stdout -> stderr

	# Log to file
	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			printf "%s" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			printf "%s" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			printf "%s" "${_msg}" >> "${_file}"
		fi
	elif [ "${_log}" != "0" ]; then
		echo "${_msg}"
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}


# Output to stdout/stderr and to file (simply output a newline).
#
# @param  string  _lvl	  Debug Level
# @param  string  _msg	  Output message
# @param  integer _log	  (0|1) 1: log to file | 0: do not log to file
# @param  string  _file	  Full path to logfile
# @param  integer _cron   (0|1) 1: Cron usage - do not print 'info' | 0: print all
# @param  string  _debug  (0|1) 1: Show debug output | 0: do not show debug output
# @return integer 0
debug_nl() {
	_lvl="${1}"		# "trace", "debug", "info", "warn" or "err" "fatal"
	_log="${2}"		# log to file?
	_file="${3}"	# full path to logfile
	_cron="${4}"	# run for cron?
	_debug="${5}"	# run in debug mode?

	# Hide info output when in cron-mode
	if [ "${_cron}" = "0" ]; then
		[ "${_lvl}" = "ok" ]   && printf "\n"
		[ "${_lvl}" = "info" ] && printf "\n"

		# Show debug output?
		if [ "${_debug}" = "1" ]; then
			[ "${_lvl}" = "debug" ] && printf "\n"
		elif [ "${_debug}" = "2" ]; then
			[ "${_lvl}" = "debug" ] && printf "\n" "${_msg}"
			[ "${_lvl}" = "trace" ] && printf "\n" "${_msg}"
		elif [ "${_debug}" != "0" ]; then
			echo "Internal Error: Invalid value for \$_debug: '${_debug}'"
			echo "Please report this at github"
			exit 1
		fi
	elif [ "${_cron}" != "0" ] && [ "${_cron}" != "1" ]; then
		echo "Internal Error: Invalid value for \$_cron: '${_cron}'"
		echo "Please report this at github"
		exit 1
	fi

	# Always show warn, error and fatal
	[ "${_lvl}" = "warn"  ] && printf "\n" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "err"   ] && printf "\n" 1>&2	# stdout -> stderr
	[ "${_lvl}" = "fatal" ] && printf "\n" 1>&2	# stdout -> stderr

	# Log to file
	if [ "${_log}" = "1" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ]; then
			printf "\n" >> "${_file}"
		fi
	elif [ "${_log}" = "2" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ]; then
			printf "\n" >> "${_file}"
		fi
	elif [ "${_log}" = "3" ]; then
		if [ "${_lvl}" = "fatal" ] || [ "${_lvl}" = "err" ] || [ "${_lvl}" = "warn" ] || [ "${_lvl}" = "ok" ] || [ "${_lvl}" = "info" ] || [ "${_lvl}" = "debug" ] || [ "${_lvl}" = "trace" ]; then
			printf "\n" >> "${_file}"
		fi
	elif [ "${_log}" != "0" ]; then
		echo "Internal Error: Invalid value for \$_log: '${_log}'"
		echo "Please report this at github"
		exit 1
	fi

	return 0
}




############################################################
# Math helper
############################################################

# Test if argument is an integer.
#
# @param  mixed
# @return integer	0: is number | 1: not a number
isint(){
	printf "%d" "$1" >/dev/null 2>&1 && return 0 || return 1;
}


# Sum up two numbers.
#
# @param  integer
# @param  integer
# @return integer
sum() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a + b}'
}

# Subtract two numbers.
#
# @param  integer
# @param  integer
# @return integer
sub() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a - b}'
}

# Divide two numbers.
#
# @param  integer
# @param  integer
# @return integer
div() {
	echo  | awk -v "a=${1}" -v "b=${2}" '{print a / b}'
}



# Round a number
#
# @param  integer	Number to round
# @param  integer	Decimal places
# @return integer
round() {
	_number="${1}"
	_precision="${2}"
	printf '%.*f\n' "${_precision}" "${_number}"
	return 0
}


#
# Get the length of a string.
#
# @param  string
# @output integer Length
str_len() {
	echo "${1}" | awk '{print length() }'
}



############################################################
# Date helper
############################################################


# Timestamp to formated date.
#
# @param  integer  Timestamp
# @param  string   Format (e.g.: '%Y-%m-%d %H:%M:%S %Z [%z')
# @output string   Formated date
# @return integer  0:success, 1:fail
formatted_timestamp() {
	_timestamp="${1}"
	_format="${2}"

	# BSD / OSX date function
	if date -r 1457171267 >/dev/null 2>&1; then
		date -r "${_timestamp}" +"${_format}"
		return 0
	# Linux date
	elif date -d @1457171267 >/dev/null 2>&1; then
		date -d @"${_timestamp}" +"${_format}"
		return 0
	fi
	echo "${_timestamp}"

	return 1
}



############################################################
# File information functions
############################################################


# Get the file mtime
# When file is modified
#
# @param  string	path to file/folder
# @output integer	File mtime (timestamp)
# @return integer	Return code
get_file_mtime() {
	_file="${1}"
	_mtime="0"
	_exit=0

	# Linux version
	if ! _mtime="$(stat -c %Y "${_file}" 2>/dev/null)"; then
		# OSX/BSD version
		if ! _mtime="$(stat -f %m "${_file}" 2>/dev/null)"; then
			# Try date
			if ! _mtime="$(date -r "${_file}" +%s 2>/dev/null)"; then
				_mtime="0"
				_exit=1
			fi
		fi
	fi

	echo "${_mtime}"
	return ${_exit}
}


# Get the file ctime
# When file is modified or when inode changes (chown/chmod)
#
# @param  string	path to file/folder
# @output integer	File mtime (timestamp)
# @return integer	Return code
get_file_ctime() {
	_file="${1}"
	_ctime="0"
	_exit=0

	# Linux version
	if ! _ctime="$(stat -c %Z "${_file}" 2>/dev/null)"; then
		# OSX/BSD version
		if ! _ctime="$(stat -f %c "${_file}" 2>/dev/null)"; then
			_ctime="0"
			_exit=1
		fi
	fi

	echo "${_ctime}"
	return ${_exit}
}



# Get file size in bytes of file or directory.
#
# @param  string	path to file/folder
# @param  char	    Unit: 'b': Bytes, 'k': KB, 'm': MB, 'g': GB (defaults to 'b')
# @output integer	File size in bytes
# @return integer	Return code
get_file_size() {
	_file="${1}"
	_unit="${2}"
	_size="0"
	_exit=1

	_size="$($(which ls) -l "${_file}" 2>/dev/null)"
	_exit=$?
	_size="$(echo "${_size}" | awk '{print $5}')"

	if [ "${_unit}" = "k" ]; then
		_size="$( div "${_size}" "1024" )"
		_size="$( round "${_size}" "2" )"
	elif [ "${_unit}" = "m" ]; then
		_size="$( div "${_size}" "1024" )"
		_size="$( div "${_size}" "1024" )"
		_size="$( round "${_size}" "2" )"
	elif [ "${_unit}" = "g" ]; then
		_size="$( div "${_size}" "1024" )"
		_size="$( div "${_size}" "1024" )"
		_size="$( div "${_size}" "1024" )"
		_size="$( round "${_size}" "2" )"
	fi

	echo "${_size}"
	return ${_exit}
}


# Get md5/sha256 hash of file or directory.
#
# @param  string	path to file/folder
# @param  string	algo: 'md5' or 'sha256' (defaults to md5)
# @output string	Hash
# @return integer	Return code
get_file_hash() {
	_file="${1}"
	_algo="${2}"
	_hash="unknown"
	_exit=1

	if [ "${_algo}" = "sha256" ]; then
		if command -v shasum > /dev/null 2>&1 ; then
			_hash="$($(which shasum) -a 256 "${_file}" 2>/dev/null)"
			_exit=$?
			_hash="$(echo "${_hash}" | awk '{print $1}')"
		elif command -v sha256sum > /dev/null 2>&1 ; then
			_hash="$($(which sha256sum) "${_file}" 2>/dev/null)"
			_exit=$?
			_hash="$(echo "${_hash}" | awk '{print $1}')"
		fi
	else
		if command -v md5 > /dev/null 2>&1 ; then
			_hash="$($(which md5) "${_file}" 2>/dev/null)"
			_exit=$?
			_hash="$(echo "${_hash}" | awk -F '=' '{print $2}' | awk '{print $1}')"
		elif command -v md5sum > /dev/null 2>&1 ; then
			_hash="$($(which md5sum) "${_file}" 2>/dev/null)"
			_exit=$?
			_hash="$(echo "${_hash}" | awk '{print $1}')"
		fi
	fi


	echo "${_hash}"
	return ${_exit}
}


# Get Operating system independent numerical 4-digit chmod value.
#
# @param  string	path to file/folder
# @output string	numerical chmod (4-digit format)
# @return integer	Return code
get_file_chmod() {
	_file="${1}"
	_perm="000"
	_exit=1

	# e.g. 640
	if [ "$(uname)" = "Linux" ]; then
		# If no special permissions are set (no sticky bit...), linux will
		# only output the 3 digit number
		_perm="$(stat --format '%a' "${_file}" 2>/dev/null)"
		_exit=$?
	else # Darwin or FreeBSD, OpenBSD, NetBSD
		_perm="$(stat -f "%Mp%Lp" "${_file}" 2>/dev/null)"
		_exit=$?
	fi

	# For special cases check the length and add a leading 0
	_len="$(echo "${_perm}" | awk '{ print length() }')"
	if [ "${_len}" = "3" ]; then
		_perm="0${_perm}"
	fi

	echo "${_perm}"
	return ${_exit}
}


# Get Operating system independent owner of file
#
# @param  string	path to file/folder
# @output string	Owner
# @return integer	Return code
get_file_owner() {
	_file="${1}"
	_owner="unknown"
	_exit=0

	# Linux version
	if ! _owner="$(stat -c %U "${_file}" 2>/dev/null)"; then
		# OSX/BSD version
		if ! _owner="$(stat -f %Su "${_file}" 2>/dev/null)"; then
			_owner="unknown"
			_exit=1
		fi
	fi

	echo "${_owner}"
	return ${_exit}
}

# Get Operating system independent group of file
#
# @param  string	path to file/folder
# @output string	Owner
# @return integer	Return code
get_file_group() {
	_file="${1}"
	_group="unknown"
	_exit=0

	# Linux version
	if ! _group="$(stat -c %G "${_file}" 2>/dev/null)"; then
		# OSX/BSD version
		if ! _group="$(stat -f %Sg "${_file}" 2>/dev/null)"; then
			_group="unknown"
			_exit=1
		fi
	fi

	echo "${_group}"
	return ${_exit}
}


# Get the real path of a file/folder if it is a symlink
#
# @param  string	path (file, folder or symlink)
# @output string	New path
# @return integer	Success
get_file_realpath() {
	_file="${1}"
	_exit=1

	_path="$(realpath "${_file}" 2>/dev/null)"
	_exit=$?

	# If path not found, return the original specified path
	if [ "${_exit}" != "0" ]; then
		_path="${_file}"
	fi

	echo "${_path}"
	return "${_exit}"
}




############################################################
# chmod/umask validator/converter
############################################################


# Validate chmod value.
#
# @param  string	numerical chmod
# @return boolean	0: valid, 1: invalid
valid_chmod() {
	_chmod="${1}"
	_len="$(echo "${_chmod}" | awk '{ print length() }')"


	if [ "${_len}" = "3" ]; then

		r="$(echo "${_chmod}" | awk '{print substr($0,1,1)}')"
		w="$(echo "${_chmod}" | awk '{print substr($0,2,1)}')"
		x="$(echo "${_chmod}" | awk '{print substr($0,3,1)}')"


		# Check if it is an integer
		if ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	elif  [ "${_len}" = "4" ]; then

		s="$(echo "${_chmod}" | awk '{print substr($0,1,1)}')"
		r="$(echo "${_chmod}" | awk '{print substr($0,2,1)}')"
		w="$(echo "${_chmod}" | awk '{print substr($0,3,1)}')"
		x="$(echo "${_chmod}" | awk '{print substr($0,4,1)}')"

		# Check if it is an integer
		if ! isint "${s}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${r}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${w}" > /dev/null 2>&1 ; then
			return 1
		elif ! isint "${x}" > /dev/null 2>&1 ; then
			return 1
		fi


		if [ "$s" -lt 0 ] || [ "$s" -gt 7 ]; then
			return 1
		fi
		if [ "$r" -lt 0 ] || [ "$r" -gt 7 ]; then
			return 1
		fi
		if [ "$w" -lt 0 ] || [ "$w" -gt 7 ]; then
			return 1
		fi
		if [ "$x" -lt 0 ] || [ "$x" -gt 7 ]; then
			return 1
		fi
		# All good
		return 0

	else
		# Nope!
		return 1
	fi
}


# Compare two chmod values.
#
# @param  string	numerical chmod (3 or 4 digits)
# @param  string	numerical chmod (3 or 4 digits)
# @return boolean	0: equals, 1: unequal
compare_chmod() {
	_chmod1="${1}"
	_chmod2="${2}"

	_len1="$(echo "${_chmod1}" | awk '{ print length() }')"
	_len2="$(echo "${_chmod2}" | awk '{ print length() }')"

	if [ "${_len1}" = "${_len2}" ]; then
		if [ "${_chmod1}" = "${_chmod2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "3" ] && [ "${_len2}" = "4" ]; then
		if [ "0${_chmod1}" = "${_chmod2}" ]; then
			return 0
		else
			return 1
		fi
	elif [ "${_len1}" = "4" ] && [ "${_len2}" = "3" ]; then
		if [ "${_chmod1}" = "0${_chmod2}" ]; then
			return 0
		else
			return 1
		fi
	else
		return 1
	fi
}


# Convert 3-digit or 4-digit chmod to 3-digit umask
#
# @param  string	numerical chmod (3 or 4 digit)
# @output string	3-digit umask
# @return integer	0
chmod_2_umask() {
	_chmod="${1}"
	_len="$(echo "${_chmod}" | awk '{ print length()   }')"

	if [ "${_len}" = "3" ]; then
		r=$(echo "${_chmod}" | awk '{print substr($0,1,1)}')
		w=$(echo "${_chmod}" | awk '{print substr($0,2,1)}')
		x=$(echo "${_chmod}" | awk '{print substr($0,3,1)}')
	elif  [ "${_len}" = "4" ]; then
		r=$(echo "${_chmod}" | awk '{print substr($0,2,1)}')
		w=$(echo "${_chmod}" | awk '{print substr($0,3,1)}')
		x=$(echo "${_chmod}" | awk '{print substr($0,4,1)}')
	fi

	ur="$(sub "7" "${r}")"
	uw="$(sub "7" "${w}")"
	ux="$(sub "7" "${x}")"

	echo "${ur}${uw}${ux}"
}



############################################################
# tmpwatch/tmpreaper checker/helper
############################################################

# Check for correct tmpwatch/tmpreaper value
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return integer   0: success, 1: failure
valid_tmpwatch() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 0 ]; then
			return 0
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 0 ]; then
			return 0
		fi
	fi

	# Fuck off
	return 1
}

# Get numerical value for tmpwatch/tmpreaper deletions
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @output integer   Value
# @return integer	Success
get_tmpwatch_value() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		echo "${_val}"
		return 0
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		echo "${_val}" | sed 's/m//g'
		return 0
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		echo "${_val}" | sed 's/h//g'
		return 0
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		echo "${_val}" | sed 's/d//g'
		return 0
	else
		echo "Internal Error: [get_tmpwatch_value] Invalid value for \$_val: '${_val}'"
		echo "Please report this at github."
		exit 1
	fi
}

# Get human readable unit for tmpwatch/tmpreaper deletions (plural or singular)
#
# @param  string    tmpwatch/tmpreaper deletion value (1, 1m, 1h, 1d)
# @return string    Human readable unit
get_tmpwatch_unit_name() {
	_val="${1}"

	# No unit (auto-defaults to hours)
	if echo "${_val}" | grep -Eq '^[0-9]+$'; then
		if [ "${_val}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'm' for minutes
	elif echo "${_val}" | grep -Eq '^[0-9]+m$'; then
		_num="$(echo "${_val}" | sed 's/m//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "minutes"
		else
			echo "minute"
		fi
	# 'h' for hours
	elif echo "${_val}" | grep -Eq '^[0-9]+h$'; then
		_num="$(echo "${_val}" | sed 's/h//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "hours"
		else
			echo "hour"
		fi
	# 'd' for days
	elif echo "${_val}" | grep -Eq '^[0-9]+d$'; then
		_num="$(echo "${_val}" | sed 's/d//g')"
		if [ "${_num}" -gt 1 ]; then
			echo "days"
		else
			echo "day"
		fi
	else
		echo "Internal Error: [get_tmpwatch_unit_name] Invalid value for \$_val: '${_val}'"
		echo "Please report this at github."
		exit 1
	fi
}



############################################################
# Nagios helper
############################################################

# Aggregate nagios exit code.
#
# OK < Warning < Error < Unknown
# @param  integer The current exit code.
# @param  integer The new exit code
# @output integer The combined exit code
# @return integer The combined exit code
merge_exit_codes() {
	_curr_exit="${1}"
	_next_exit="${2}"

	# OK
	if [ "${_curr_exit}" = "0" ]; then
		_curr_exit="${_next_exit}"
	# Warning
	elif [ "${_curr_exit}" = "1" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="1"
		fi
	# Error
	elif [ "${_curr_exit}" = "2" ]; then
		_curr_exit="2"
	# Unknown
	elif [ "${_curr_exit}" = "3" ]; then
		if [ "${_next_exit}" = "0" ]; then
			_curr_exit="3"
		elif [ "${_next_exit}" = "1" ]; then
			_curr_exit="1"
		elif [ "${_next_exit}" = "2" ]; then
			_curr_exit="2"
		elif [ "${_next_exit}" = "3" ]; then # UNKNOWN -> WARNING
			_curr_exit="3"
		fi
	fi
	echo "${_curr_exit}"
	return ${_curr_exit}
}





################################################################################
#
#  M Y S Q L   F U N C T I O N S
#
################################################################################


############################################################
# MySQL Connection Helper
############################################################


# Test if connection to the server is successful.
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  Error message
# @return integer Success (0: OK | 1: Error)
mysql_test_connection() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_error=""
	_errno=0

	# Redirect stderr into stdout and both into variable
	_error="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" -e exit 2>&1 )"
	_errno=$?

	if [ "${_errno}" != "0" ] || [ "${_error}" != "" ]; then
		echo "${_error}"
		return 1
	else
		return 0
	fi
}


############################################################
# MySQL Server Info Helper
############################################################

# Get MySQL server status 'status;'
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  MySQL 'status;'
# @return integer Success (0: OK | 1: Error)
get_mysql_server_status() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_exit=1

	_query="status;"
	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	echo "${_result}"
	return ${_exit}
}

# Get MySQL server hostname
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  Hostname
# @return integer Success (0: OK | 1: Error)
get_mysql_server_hostname() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_exit=1

	_query="SHOW GLOBAL VARIABLES LIKE 'HOSTNAME';"

	# Redirect stderr into stdout and both into variable
	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	_result="$( echo "${_result}" | tail -n1 | sed 's/hostname[[:space:]]*//g' )"

	echo "${_result}"
	return ${_exit}
}

# Get MySQL server port
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  Port
# @return integer Success (0: OK | 1: Error)
get_mysql_server_port() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_exit=1

	_query="SHOW GLOBAL VARIABLES LIKE 'PORT';"

	# Redirect stderr into stdout and both into variable
	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	_result="$( echo "${_result}" | tail -n1 | sed 's/port[[:space:]]*//g' )"

	echo "${_result}"
	return ${_exit}
}

# Determines wheter the server connected to
# is
# * a master without replication (single)
# * a master with replication (master)
# * a slave
# * or unknown
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  Type (unknown|master|slave)
# @return integer Success (0: OK | 1: Error)
get_mysql_server_replication_type() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_exit=1

	_query="select COUNT(1) SlaveThreads from information_schema.processlist where user = 'system user';"
	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	_result="$( echo "${_result}" | tail -n1 )"

	if [ "${_exit}" != "0" ]; then
		echo "unknown"
		return ${_exit}
	else
		if [ "${_result}" = "0" ]; then
			echo "master"
			return ${_exit}
		elif  [ "${_result}" -gt "0" ]; then
			echo "slave"
			return ${_exit}
		else
			echo "unknown"
			return 1
		fi
	fi
}

# Get MySQL Server Version
#
# @param  string  MySQL server 'status;' output
# @output string  Server Version
# @return integer 0
get_mysql_server_version() {
	_mysql_server_status="${1}"

	echo "${_mysql_server_status}" | grep -E '^Server version:.*' | sed 's/Server version:[[:space:]]*//g'
	return 0
}

# Get MySQL Server Name (MySQL or MariaDB)
#
# @param  string  MySQL server 'status;' output
# @output string  Server name
# @return integer 0
get_mysql_server_name() {
	_mysql_server_status="${1}"

	echo "${_mysql_server_status}" | grep -E '^Server:.*' | sed 's/Server:[[:space:]]*//g'
	return 0
}


############################################################
# MySQL Connection Info Helper
############################################################

# Get MySQL connection info (TCP/IP or Socket)
#
# @param  string  MySQL server 'status;' output
# @output string  Connection type (TCP/IP or Socket)
# @return integer 0
get_mysql_connection_type_info() {
	_mysql_server_status="${1}"

	echo "${_mysql_server_status}" | grep -E '^Connection:.*' | sed 's/Connection:[[:space:]]*//g'
	return 0
}

# Get MySQL connection info about SSL status
#
# @param  string  MySQL server 'status;' output
# @output string  SSL Connection info
# @return integer 0
get_mysql_connection_ssl_info() {
	_mysql_server_status="${1}"

	echo "${_mysql_server_status}" | grep -E '^SSL:.*' | sed 's/SSL:[[:space:]]*//g'
	return 0
}



############################################################
# MySQL Database Helper
############################################################


# Get all databas names
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output string  All databases (including empty ones)
# @return integer Success (0: OK | 1: Error)
get_mysql_databases() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_exit=1

	_query="show databases;"
	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	# Only gets databases which have content (tables)
	#DATABASES="$( ${MYSQL} --defaults-file="${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" --no-auto-rehash --skip-column-names -e 'SELECT DISTINCT table_schema FROM information_schema.tables;')"

	# Remove first column (is sql column name)
	_result="$( echo "${_result}" | sed 1d )"

	# output all databases on success
	if [ "${_exit}" = "0" ]; then
		echo "${_result}"
	fi

	return "${_exit}"
}

# Get number of databases
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output integer Number of databases
# @return integer 0
get_mysql_database_count() {
	_databases="${1}"
	echo "${_databases}" | wc -l | tr -d ' '
	return 0
}

# Get database size in btyes
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @output integer Database size in bytes
# @return integer Success (0: OK | 1: Error)
get_mysql_database_size() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_database="${3}"
	_exit=1

	_query="SELECT SUM(DATA_LENGTH + INDEX_LENGTH) AS Size
				FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_SCHEMA = '${_database}';"


	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?

	_result="$( echo "${_result}" | tail -n1 )"

	echo "${_result}"
	return ${_exit}
}

# Determines whether database is empty
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @return integer 0: Empty | 1: Not empty
mysql_database_is_empty() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_database="${3}"


	# If a database does not show up in information_schema.tables, it means it
	# has no tables yet and is therefore empty.
	# If count == 0, return '0', else '1'
	_query="SELECT IF(COUNT(*) = 0, '0', '1') AS empty
				FROM INFORMATION_SCHEMA.TABLES
				WHERE TABLE_SCHEMA = '${_database}';"

	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_result="$( echo "${_result}" | tail -n1 )"

	return "${_result}"
}



# Get all table names and table-engines
# as a multiline string, separated by a custom
# separator
#
# @param  string  Credentials file (mysqldump-secure.cnf).
# @param  string  SSL connection options.
# @param  string  Database.
# @param  char    Separator
# @return integer 0: Empty | 1: Not empty
get_mysql_database_table_names_and_engines() {
	_cnf_file="${1}"
	_ssl_opts="${2}"
	_database="${3}"
	_separator="${4}"
	_exit=1


	# Get NAME<sep>ENGINE list for given database
	_query="SELECT CONCAT(TABLE_NAME, '${_separator}',ENGINE) AS t
				FROM information_schema.TABLES
				WHERE TABLE_SCHEMA = '${_database}';"

	_result="$( $(which mysql) --defaults-file="${_cnf_file}" "${_ssl_opts}" --batch -e "${_query}" 2>/dev/null)"
	_exit=$?
	_result="$( echo "${_result}" | grep -E "^.*[${_separator}].*$")"


	echo "${_result}"
	return ${_exit}
}



################################################################################
#
#  D A T A B A S E   I G N O R E / R E Q U I R E   H E L P E R
#
################################################################################

# Check if the specified database should be ignored
# This can either be by the full name or a wildcard with '*'
#
# @param  string  Ignore list
# @param  string  Database name
# @output string  Ignore pattern
# @return integer 0: ignored, 1: not ignored
database_is_ignored() {
	_ignore_list="${1}"
	_database="${2}"

	# Default exit with 1, which means
	# it was not found.
	_exit=1

	# The ignore pattern if it was ignored
	_pattern=""

	# We need to disable "variable globbing" (set -f) here,
	# because if there is only a '*' inside '$IGNORE'
	# then
	#       'for ign_db in ${IGNORE}; do'
	# would list all files in the current directory.
	set -f
	for _ignore_pattern in ${_ignore_list}; do

		# Replace '*' with '.*' to create a regex pattern
		_regex="$(echo "${_ignore_pattern}" | sed 's/\*/\.\*/')"

		# Check if the pattern matches the complete db name
		_found="$(echo "${_database}" | grep -oe "${_regex}")"

		if [ "${_found}" = "${_database}" ]; then

			# Assign new ignore pattern
			_pattern="${_ignore_pattern}"

			# Return with 0 to indicate it was found
			_exit=0

			# Stop the loop
			break
		fi
	done
	set +f

	echo "${_pattern}"
	return ${_exit}
}

# Check if the specified database is required.
#
# @param  string  Require list
# @param  string  Database name
# @return integer 0: required, 1: not required
database_is_required() {
	_require_list="${1}"
	_database="${2}"

	# Now check if the ignored db is actually a required db inside $REQUIRE
	for _db_required in ${_require_list}; do
		# Required database found?
		if [ "${_database}" = "${_db_required}" ]; then
			# Returning 0 indicates it is required
			return 0
		fi
	done

	# Returning invalid return code indicates it is not required
	return 1

}


################################################################################
#
#  M I S C   F U N C T I O N S
#
################################################################################




# Determine the file extension
# based on encrypted/compressed files
#
# @param  integer _encrypt       Encryption enabled? (0: off | 1: on)
# @param  integer _compress      Compression enabled? (0: off | 1: on)
# @param  string  _compress_ext  Compression extension (e.g.: gz)
# @output string   File extension
build_file_extension() {
	_encrypt="${1}"
	_compress="${2}"
	_compress_ext="${3}"

	# Get file extension
	if [ "${_compress}" = "1" ]; then
		if [ "${_encrypt}" = "1" ]; then
			echo ".sql.${_compress_ext}.enc"
		else
			echo ".sql.${_compress_ext}"
		fi
	else
		if [ "${_encrypt}" = "1" ]; then
			echo ".sql.enc"
		else
			echo ".sql"
		fi
	fi
}



# Validate mysqldump-secure.cnf file
#
# The only allowed directives are:
#   [client]
#   socket =
#   host =
#   port =
#   user =
#   password =
# "[client]" must also be the first non-commented
# directive.
#
# @param  string  mysqldump-secure.cnf file path
# @output string  Error message
# @return integer 0: valid | 1: invalid
validate_cnf_file() {
	_file_path="${1}"

	# Get contents
	cnf="$(cat "${_file_path}")"

	# Remove line comments ('#' and ';')
	cnf="$(echo "${cnf}" | sed 's/^[[:space:]]*#.*$//g')"
	cnf="$(echo "${cnf}" | sed 's/^[[:space:]]*;.*$//g')"

	# Remove empty lines
	cnf="$(echo "${cnf}" | sed '/^$/d')"

	# Remove leading spaces
	cnf="$(echo "${cnf}" | sed 's/^[[:space:]]*//g')"

	# Remove trailing spaces
	cnf="$(echo "${cnf}" | sed 's/[[:space:]]*$//g')"

	IFS='
	'
	i=0
	set -f
	for _line in ${cnf}; do
		i=$((i + 1))

		# Everything before the '=' is the actual directive to check against
		# E.g: "host = localhost" results in "host"
		_directive="$(echo "${_line}" | awk -F '=' '{print $1}' | sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g')"

		# Check for '[client]' in the first non-commented line
		if [ "${i}" = "1" ] && [ "${_line}" != "[client]" ]; then
			echo "The first non-commented line must contain a \"[client]\" directive"
			return 1
		fi

		# Only allow the following directives
		if  [ "${_directive}" != "[client]" ] &&
			[ "${_directive}" != "socket" ] &&
			[ "${_directive}" != "host" ] &&
			[ "${_directive}" != "port" ] &&
			[ "${_directive}" != "user" ] &&
			[ "${_directive}" != "password" ]; then
			echo "Invalid directive found: \"${_directive}\""
			return 1
		fi

	done
	set +f
	unset IFS

	# All fine, nothing bad found.
	return 0
}





################################################################################
#
#  U S A G E   F U N CT I O N S
#
################################################################################



############################################################
# Usage/Help/Version
############################################################

#
# Usage
#
print_usage() {
#	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cnf] [--cron] [-v[v]] [--test] [--info] [--help] [--version]"
	printf "%s %s %s\n" "Usage:" "${INFO_NAME}" "[--conf] [--cron] [--test] [-v[v]]"
#	printf "%s %s %s\n" "      " "${INFO_NAME}" "--info"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--help"
	printf "%s %s %s\n" "      " "${INFO_NAME}" "--version"
}

#
# Display program usage
#
print_help() {

	print_usage
	echo
	echo "When invoked without any arguments, it will start dumping databases as"
	echo "defined in mysqldump-secure.conf."
	echo
	echo "  --conf          Pass a different configuration file than the default one."
	echo "                  E.g.: --conf=/etc/mysqldump-secure-alt.conf"
	echo
#	echo "  --cnf           Pass different mysql cnf credentials file than the default one."
#	echo "                  E.g.: --cnf=/etc/mysqldump-secure-slave.cnf"
#	echo
	echo "  --cron          Use for cron run. It will only output errors and warnings"
	echo "                  and will silence all info, debug and trace output."
	echo
	echo "  --test          Test requirements and exit."
	echo "                  Combine with -v or -vv for more verbose output."
	echo
	echo "  -v              Show debug output."
	echo "                  Can be combined with --conf  and --test"
	echo
	echo "  -vv             Show debug and trace output."
	echo "                  Can be combined with --conf  and --test"
	echo
#	echo "  --info          Show settings and exit."
#	echo
	echo "  --help          Show this help screen."
	echo
	echo "  --version       Show version information."
	echo
	echo
	echo "Exit codes"
	echo
	echo "  0               All fine, no fatals, no errors and no warnings occured."
	echo "  1               Warnings occured, but all dumps were successfull."
	echo "  2               Errors occured, but all dumps were successfull."
	echo "  3               Failed. Mysqldump encountered errors."
	echo "  4               Abort. The program aborted, due to missing requirements,"
	echo "                  wrong arguments or a misconfiguration."
	echo
	echo "Further reading"
	echo
	echo "See 'man mysqldump-secure' for more help."
	echo "Visist http://mysqldump-secure.org and browse documentation."
}
# TODO:
# --------
# --info			Shows current configuration and paths
# --cli				Start interactive cli (mysqldump-secure-cli) to show dumps, import dumps, set configs, etc



#
# Display program version and credits
#
print_version() {
	printf "Name:    %s\n" "${INFO_NAME}"
	printf "Version: %s (%s)\n" "${INFO_VERSION}" "${INFO_DATE}"
	printf "Author:  %s (%s)\n" "${INFO_AUTHOR}" "${INFO_GPGKEY}"
	printf "Code:    %s\n" "${INFO_REPO}"
	printf "URL:     %s\n" "${INFO_URL}"
	printf "License: %s\n" "${INFO_LICENSE}"
}









####################################################################################################
####################################################################################################
##
##  M A I N   E N T R Y   P O I N T
##
####################################################################################################
####################################################################################################



################################################################################
#
# COMMAND LINE ARGUMENTS
#
################################################################################

############################################################
# 1.) Evaluate cmd arguments
############################################################


_ARG_CONF="0"	# Different config file specified?
_ARG_VERB="0"	# Verbose mode?
_ARG_CRON="0"	# Cron mode?
_ARG_TEST="0"	# Test mode?
_ARG_HELP="0"	# Show help?
_ARG_VERS="0"	# Show version?

_CUS_CONF=""	# Where is the custom config?
#_ARG_INFO="0"


#
# Loop over command line arguments
#
while [ $# -gt 0  ]; do
	case "$1" in

		--conf=*)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_CONF}" != "0" ]; then
				echo "Invalid. Argument '--conf' already specified."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_CONF="1"
			_CUS_CONF="$(echo "$1" | sed 's/--conf=//g')"
			;;


		-v)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ] || [ "${_ARG_CRON}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_VERB}" != "0" ]; then
				echo "Invalid. Argument '-v' already specified (use -vv for more verbosity)."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_VERB="1"
			;;


		-vv)
			if [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ] || [ "${_ARG_CRON}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_VERB}" != "0" ]; then
				echo "Invalid. Argument '-v' already specified (use -vv for more verbosity)."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_VERB="2"
			;;


		--cron)
			if [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ] || [ "${_ARG_VERB}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_CRON}" != "0" ]; then
				echo "Invalid. Argument '--cron' already specified."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_CRON="1"
			;;


		--test)
			if [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERS}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_TEST}" != "0" ]; then
				echo "Invalid. Argument '--test' already specified."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_TEST="1"
			;;

#		--info)
#			_ARG_INFO="1"
#			;;


		--help)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_VERS}" = "1" ] || [ "${_ARG_VERB}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_HELP}" != "0" ]; then
				echo "Invalid. Argument '--help' already specified."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_HELP="1"
			print_help
			exit 0
			;;


		--version)
			if [ "${_ARG_CONF}" = "1" ] || [ "${_ARG_CRON}" = "1" ] || [ "${_ARG_TEST}" = "1" ] || [ "${_ARG_HELP}" = "1" ] || [ "${_ARG_VERB}" = "1" ]; then
				echo "Invalid. Arguments cannot be mixed."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			if [ "${_ARG_VERS}" != "0" ]; then
				echo "Invalid. Argument '--versopm' already specified."
				echo "Type '${INFO_NAME} --help' for available options."
				exit $EXIT_ABORT
			fi
			_ARG_VERS="1"
			print_version
			exit 0
			;;


		*)
			echo "Invalid argument: '${1}'."
			echo "Type '${INFO_NAME} --help' for available options."
			exit $EXIT_ABORT
			;;

	esac
	shift
done


# Use default config or user specified config file
if [ -z "${_CUS_CONF-}" ]; then
	CONFIG_FILE="${_DEFAULT_CONFIG_FILE}"
else
	CONFIG_FILE="${_CUS_CONF}"
fi


############################################################
# Config File
############################################################

if [ ! -f "${CONFIG_FILE}" ]; then
	debug "fatal" "(RUN): Configuration file not found in ${CONFIG_FILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi
if [ -L "${CONFIG_FILE}" ]; then
	if _TMP="$(get_file_realpath "${CONFIG_FILE}")" >/dev/null 2>&1; then
		debug "trace" "(RUN): \$CONFIG_FILE is a symlink. Setting target to: ${_TMP}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		CONFIG_FILE="${_TMP}"
	else
		debug "fatal" "(RUN): Cannot resolve symlink of: $CONFIG_FILE" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi
fi
if [ ! -r "${CONFIG_FILE}" ]; then
	debug "fatal" "(RUN): Configuration file is not readable in ${CONFIG_FILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi
if ! compare_chmod "$(get_file_chmod "${CONFIG_FILE}")" "${_DEFAULT_CONFIG_CHMOD}" > /dev/null 2>&1 ; then
	debug  "warn" "(RUN): Configuration file ${CONFIG_FILE} has dangerous permissions: $(get_file_chmod "${CONFIG_FILE}"), should be: ${_DEFAULT_CONFIG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debugi "warn" "(RUN): Trying to chmod to ${_DEFAULT_CONFIG_CHMOD}..." "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

	if ! chmod ${_DEFAULT_CONFIG_CHMOD} "${CONFIG_FILE}" > /dev/null 2>&1 ; then
		debugn "fatal" "Failed" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug  "fatal" "Failed to chmod ${CONFIG_FILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug  "fatal" "Fix it manually to ${_DEFAULT_CONFIG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug  "fatal" "Aborting" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	else
		debugn "warn" "OK" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
fi



# Read config file
# Comment required by shellcheck,
# See problem here: https://github.com/koalaman/shellcheck/wiki/SC1090
# shellcheck disable=SC1090
#
# TODO: Manually parse the file via sed or awk to be safer
. "${CONFIG_FILE}"





################################################################################
#
# EVALUATE CONFIG FILE
#
################################################################################


############################################################
# Logging Options
############################################################

# Be really strict on checking if we are going to log to file
# or not. Also make sure that the logfile is writeable and
# that no other has read permissions to the file.
if ! set | grep '^LOG=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$LOG variable is not defined" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOG=0
	LOGFILE=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${LOG}" ]; then
	debug "warn" "(CFG): \$LOG variable should not be empty" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOG=0
	LOGFILE=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${LOG}" = "1" ] || [ "${LOG}" = "2" ] || [ "${LOG}" = "3" ]; then

	# Check chmod variable
	if ! set | grep '^LOG_CHMOD=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$LOG_CHMOD variable is not defined" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${LOG_CHMOD}" ]; then
		debug "warn" "(CFG): \$LOG_CHMOD variable should not be empty" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif ! valid_chmod "${LOG_CHMOD}" > /dev/null 2>&1; then
		debug "warn" "(CFG): Invalid value for \$LOG_CHMOD: ${LOG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(CFG): Setting default to: ${_DEFAULT_LOG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOG_CHMOD="${_DEFAULT_LOG_CHMOD}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	fi

	# Check logfile variable
	if ! set | grep '^LOGFILE=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$LOGFILE variable is not defined" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Setting default to: ${_DEFAULT_LOGFILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOGFILE="${_DEFAULT_LOGFILE}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${LOGFILE}" ]; then
		debug "warn" "(CFG): \$LOGFILE variable should not be empty" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Setting default to: ${_DEFAULT_LOGFILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
		LOGFILE="${_DEFAULT_LOGFILE}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	fi

	# Resolve symlink?
	if [ -L "${LOGFILE}" ]; then
		if _TMP="$(get_file_realpath "${LOGFILE}")" >/dev/null 2>&1; then
			debug "trace" "(RUN): \$LOGFILE is a symlink. Setting target to: ${_TMP}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			LOGFILE="${_TMP}"
		else
			debug "err" "(RUN): Cannot resolve symlink of: $LOGFILE" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			LOG=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		fi
	fi

	# Check if logfile exists
	if [ ! -f "${LOGFILE}" ]; then
		# Check if logging directory exists
		if [ ! -d "$(dirname "${LOGFILE}")" ]; then
			debug  "warn" "(RUN): Logfile directory does not exist in $(dirname "${LOGFILE}")" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debugi "warn" "(RUN): Trying to create..." "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
			if ! mkdir -p "$(dirname "${LOGFILE}")" > /dev/null 2>&1 ; then
				debugn "err" "Failed" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err" "(RUN): Failed to create directoy: $(dirname "${LOGFILE}")" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				LOG=0
				MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
			else
				debugn "warn" "OK" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			fi
		fi
		# If logging is still OK (dir exists), check if the file can be created
		if [ "${LOG}" != "0" ]; then
			debug  "warn" "(RUN): Logfile does not exist in ${LOGFILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debugi "warn" "(RUN): Trying to create..." "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

			if ! touch "${LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(RUN): Failed to create file: ${LOGFILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				LOG=0
				MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
			else
				debugn "warn" "OK" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			fi
		fi
	fi

	# Logging still on?
	# Check for permissions
	if [ "${LOG}" != "0" ]; then
		if ! compare_chmod "$(get_file_chmod "${LOGFILE}")" "${LOG_CHMOD}" > /dev/null 2>&1 ; then
			debug  "warn" "(RUN): Logfile has wrong permissions: $(get_file_chmod "${LOGFILE}"), should be: ${LOG_CHMOD}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debugi "warn" "(RUN): Trying to chmod to ${LOG_CHMOD}..." "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

			if ! chmod ${LOG_CHMOD} "${LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(RUN): Failed to chmod ${LOG_CHMOD} ${LOGFILE}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
				LOG=0
				MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
			else
				debugn "warn" "OK" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			fi
		fi
	fi

	# Logging still on?
	# Check if it is writeable
	if [ "${LOG}" != "0" ]; then

		# Logfile not writeable
		if [ ! -w "${LOGFILE}" ]; then
			debug  "err" "(RUN): Logfile ${LOGFILE} not writeable. Check \$LOG_CHMOD value inf config." "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "err" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
			LOG=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		fi
	fi
elif [ "${LOG}" = "0" ]; then
	debug "info" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOGFILE=""
else
	debug "warn" "(CFG): Invalid value for \$LOG: ${LOG}" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Logging disabled" "0" "" "${_ARG_CRON}" "${_ARG_VERB}"
	LOG=0
	LOGFILE=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Is logging still enabled after all checks?
# Write to the file
if [ "${LOG}" != "0" ]; then
	{
		echo;
		echo "--------------------------------------------------------------------------------";
		echo "$(date '+%Y-%m-%d') $(date '+%H:%M:%S') Starting";
	} >> "${LOGFILE}"
	debug "trace" "(CFG): Using config: ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "info"  "(OPT): Logging enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "debug" "(OPT): Log level: ${LOG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "debug" "(OPT): Logfile: ${LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "trace" "(CFG): Using config: ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi



############################################################
# Command line arguments
############################################################
if [ "${_ARG_CRON}" = "1" ]; then
	debug "trace" "(ARG): Running in cron mode (--cron)." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi
if [ "${_ARG_TEST}" = "1" ]; then
	debug "trace" "(ARG): Running tests only (--test)." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi
if [ "${_ARG_VERB}" = "1" ]; then
	debug "trace" "(ARG): Running in verbose mode (--verbose)." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi
#if [ "${_ARG_INFO}" = "1" ]; then
#	debug "info" "Showing information only (--info)."  $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
#fi



############################################################
# Tmp folder
############################################################


# Check if mktemp exits
if ! command -v mktemp > /dev/null 2>&1 ; then
	debug "fatal" "(RUN): 'mktemp' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Check $TMP_DIR variable
if ! set | grep '^TMP_DIR=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$TMP_DIR variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	TMP_DIR=${_DEFAULT_TMP_DIR}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${TMP_DIR}" ]; then
	debug "warn" "(CFG): \$TMP_DIR variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	TMP_DIR=${_DEFAULT_TMP_DIR}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Check directory
if [ ! -d "${TMP_DIR}" ]; then
	debug "fatal" "(CFG): \$TMP_DIR is not a directory: ${TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): Change value of \$TMP_DIR in your config" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ ! -w "${TMP_DIR}" ]; then
	debug "fatal" "(CFG): \$TMP_DIR is not writeable" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): Change value of \$TMP_DIR in your config" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi
debug "trace" "(CFG): Using temporary directory: ${TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"




############################################################
# Destination Directory and Prefix
############################################################

# Check $DUMP_DIR_CHMOD
if ! set | grep '^DUMP_DIR_CHMOD=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_DIR_CHMOD variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DUMP_DIR_CHMOD}" ]; then
	debug "warn" "(CFG): \$DUMP_DIR_CHMOD variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif ! valid_chmod "${DUMP_DIR_CHMOD}" > /dev/null 2>&1; then
	debug "warn" "(CFG): Invalid value for \$DUMP_DIR_CHMOD: ${DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR_CHMOD="${_DEFAULT_DUMP_DIR_CHMOD}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Check $DUMP_FILE_CHMOD
if ! set | grep '^DUMP_FILE_CHMOD=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_FILE_CHMOD variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DUMP_FILE_CHMOD}" ]; then
	debug "warn" "(CFG): \$DUMP_FILE_CHMOD variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD=${_DEFAULT_DUMP_DIR_CHMOD}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif ! valid_chmod "${DUMP_FILE_CHMOD}" > /dev/null 2>&1; then
	debug "warn" "(CFG): Invalid value for \$DUMP_FILE_CHMOD: ${DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_CHMOD="${_DEFAULT_DUMP_DIR_CHMOD}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Check $DUMP_DIR
if ! set | grep '^DUMP_DIR=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_DIR variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR=${_DEFAULT_DUMP_DIR}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DUMP_DIR}" ]; then
	debug "warn" "(CFG): \$DUMP_DIR variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_DIR=${_DEFAULT_DUMP_DIR}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Resolve symlink?
if [ -L "${DUMP_DIR}" ]; then
	if _TMP="$(get_file_realpath "${DUMP_DIR}")" >/dev/null 2>&1; then
		debug "trace" "(RUN): \$DUMP_DIR is a symlink. Setting target to: ${_TMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DUMP_DIR="${_TMP}"
	else
		debug "fatal" "(RUN): Cannot resolve symlink of: $DUMP_DIR" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi
fi

if [ ! -d "${DUMP_DIR}" ]; then
	debug  "warn" "(RUN): Destination dir does not exist: ${DUMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugi "warn" "(RUN): Trying to create... " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

	if ! mkdir -p "${DUMP_DIR}" > /dev/null 2>&1 ; then
		debugn "fatal"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug  "fatal"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	else
		debugn "warn" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugi "warn" "(RUN): Trying to chmod to: ${DUMP_DIR_CHMOD}..." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		if ! chmod ${DUMP_DIR_CHMOD} "${DUMP_DIR}" >/dev/null 2>&1; then
			debugn "fatal"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "fatal"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			exit $EXIT_ABORT
		else
			debugn "warn" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi
	fi
fi

# Check correct permissions of destination dir
if ! compare_chmod "$(get_file_chmod "${DUMP_DIR}")" "${DUMP_DIR_CHMOD}" > /dev/null 2>&1 ; then
	debug  "warn" "(RUN): Destination dir has wrong permissions: $(get_file_chmod "${DUMP_DIR}"), but should ${DUMP_DIR_CHMOD}." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugi "warn" "(RUN): Trying to chmod to ${DUMP_DIR_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

	if ! chmod "${DUMP_DIR_CHMOD}" "${DUMP_DIR}" > /dev/null 2>&1 ; then
		debugn "fatal" "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug  "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	else
		debugn "warn" "Done" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
fi
# Check if destination dir is writeable
if [ ! -w "${DUMP_DIR}" ]; then
	debug  "fatal" "(RUN): Destination dir ${DUMP_DIR} is not writeable" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugi "fatal" "(HLP): Fix your configured permissions" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug  "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Show information
debug "debug" "(CFG): Destination dir: ${DUMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


# Check $DUMP_FILE_PRE
if ! set | grep '^DUMP_FILE_PRE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_FILE_PRE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_PRE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_PRE=${_DEFAULT_DUMP_FILE_PRE}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DUMP_FILE_PRE}" ]; then
	debug "warn" "(CFG): \$DUMP_FILE_PRE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_DUMP_FILE_PRE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_PRE=${_DEFAULT_DUMP_FILE_PRE}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# Show information
debug "debug" "(CFG): Using file Prefix: ${DUMP_FILE_PRE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"



############################################################
# MySQL
############################################################

# Check Binaries
if ! command -v mysql > /dev/null 2>&1 ; then
	debug "fatal" "(RUN): 'mysql' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi
if ! command -v mysqldump > /dev/null 2>&1 ; then
	debug "fatal" "(RUN): 'mysqldump' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Check $MYSQL_CNF_FILE
if ! set | grep '^MYSQL_CNF_FILE=' >/dev/null 2>&1; then
	debug "fatal" "(CFG): \$MYSQL_CNF_FILE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ -z "${MYSQL_CNF_FILE}" ]; then
	debug "fatal" "(CFG): \$MYSQL_CNF_FILE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Resolve symlink?
if [ -L "${MYSQL_CNF_FILE}" ]; then
	if _TMP="$(get_file_realpath "${MYSQL_CNF_FILE}")" >/dev/null 2>&1; then
		debug "trace" "(RUN): \$MYSQL_CNF_FILE is a symlink. Setting target to: ${_TMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MYSQL_CNF_FILE="${_TMP}"
	else
		debug "fatal" "(RUN): Cannot resolve symlink of: $MYSQL_CNF_FILE" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi
fi

# Check access and chmod
if [ ! -f "${MYSQL_CNF_FILE}" ]; then
	debug "fatal" "(RUN): MySQL CNF file not found: ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ ! -r "${MYSQL_CNF_FILE}" ]; then
	debug "fatal" "(RUN): MySQL CNF file is not readable: ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif ! compare_chmod "$(get_file_chmod "${MYSQL_CNF_FILE}")" "${_DEFAULT_MYSQL_CNF_CHMOD}" > /dev/null 2>&1 ; then
	debug "fatal" "(RUN): MySQL CNF file has dangerous permissions: $(get_file_chmod "${MYSQL_CNF_FILE}")." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): Fix it to ${_DEFAULT_MYSQL_CNF_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): If you are not alone on the machine, the password inside could have been compromised by now." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): If so, change your database password." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Validate contents
if ! _MSG="$(validate_cnf_file "${MYSQL_CNF_FILE}")"; then
	debug "fatal" "(RUN): Invalid cnf file." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): ${_MSG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi



# Check MYSQL_SSL_ENABLE
if ! set | grep '^MYSQL_SSL_ENABLE=' >/dev/null 2>&1; then
	debug "fatal" "(CFG): \$MYSQL_SSL_ENABLE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ -z "${MYSQL_SSL_ENABLE}" ]; then
	debug "fatal" "(CFG): \$MYSQL_SSL_ENABLE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ "${MYSQL_SSL_ENABLE}" = "1" ]; then
	if ! set | grep '^MYSQL_SSL_CA_PEM=' >/dev/null 2>&1; then
		debug "fatal" "(CFG): \$MYSQL_SSL_CA_PEM variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal"  "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	elif [ -z "${MYSQL_SSL_CA_PEM}" ]; then
		debug "fatal" "(CFG): \$MYSQL_SSL_CA_PEM variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	elif [ ! -f "${MYSQL_SSL_CA_PEM}" ]; then
		debug "fatal" "(RUN): \$MYSQL_SSL_CA_PEM=\"$MYSQL_SSL_CA_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "(HLP): It is required for SSL connections" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi

	MYSQL_SSL_ARGS="--ssl-ca=${MYSQL_SSL_CA_PEM}"

	# MYSQL_SSL_CLIENT_CERT_PEM
	if [ -n "${MYSQL_SSL_CLIENT_CERT_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_CERT_PEM}" ]; then
			debug "fatal" "(RUN): \$MYSQL_SSL_CLIENT_CERT_PEM=\"$MYSQL_SSL_CLIENT_CERT_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(HLP): Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			exit $EXIT_ABORT
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-cert=${MYSQL_SSL_CLIENT_CERT_PEM}"
	fi
	# MYSQL_SSL_CLIENT_KEY_PEM
	if [ -n "${MYSQL_SSL_CLIENT_KEY_PEM-}" ]; then
		if [ ! -f "${MYSQL_SSL_CLIENT_KEY_PEM}" ]; then
			debug "fatal" "(RUN): \$MYSQL_SSL_CLIENT_KEY_PEM=\"$MYSQL_SSL_CLIENT_KEY_PEM\" does not exist" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(HLP): Comment it out or specify the correct path." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			exit $EXIT_ABORT
		fi
		MYSQL_SSL_ARGS="${MYSQL_SSL_ARGS} --ssl-key=${MYSQL_SSL_CLIENT_KEY_PEM}"
	fi

	debug "info"  "(OPT): MySQL SSL connection enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "debug" "(OPT): MySQL SSL arguments: ${MYSQL_SSL_ARGS}." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${MYSQL_SSL_ENABLE}" = "0" ]; then
	MYSQL_SSL_ENABLE=0
	MYSQL_SSL_ARGS=""
	debug "info" "(OPT): MySQL SSL connection disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "fatal" "(CFG): Wrong value for \$MYSQL_SSL_ENABLE: $MYSQL_SSL_ENABLE" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow secure connections." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi




############################################################
# MySQL Dump Opts
############################################################

# MYSQL_OPTS
if ! set | grep '^MYSQL_OPTS=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$MYSQL_OPTS variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): Setting default to no custom mysqldump options" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${MYSQL_SSL_ENABLE}" ]; then
	debug "trace" "(CFG): \$MYSQL_OPTS is empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS=""
fi

debug "trace"  "(CFG): mysqldump custom options: ${MYSQL_OPTS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


# MYSQL_OPTS_QUICK_MIN_SIZE
if ! set | grep '^MYSQL_OPTS_QUICK_MIN_SIZE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$MYSQL_OPTS_QUICK_MIN_SIZE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS_QUICK_MIN_SIZE=${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${MYSQL_OPTS_QUICK_MIN_SIZE}" ]; then
	debug "warn" "(CFG): \$MYSQL_OPTS_QUICK_MIN_SIZE is empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS_QUICK_MIN_SIZE=${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif ! isint "${MYSQL_OPTS_QUICK_MIN_SIZE}" >/dev/null 2>&1; then
	debug "warn" "(CFG): Wrong integer value for \$MYSQL_OPTS_QUICK_MIN_SIZE: ${MYSQL_OPTS_QUICK_MIN_SIZE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(CFG): Setting default to: ${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MYSQL_OPTS_QUICK_MIN_SIZE=${_DEFAULT_MYSQL_OPTS_QUICK_MIN_SIZE}
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi
debug "trace"  "(CFG): mysqldump '--quick':      Applied to DB's >= ${MYSQL_OPTS_QUICK_MIN_SIZE} MB" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
debug "trace"  "(CFG): mysqldump '--skip-quick': Applied to DB's  < ${MYSQL_OPTS_QUICK_MIN_SIZE} MB" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


############################################################
# Bad MySQL Opts
############################################################
for opt in ${MYSQL_OPTS}; do
	for evil in ${MYSQL_EVIL_OPTS}; do
		if echo "${opt}" | grep -e "^${evil}" > /dev/null 2>&1; then
			debug "fatal" "(CFG): Insecure mysqldump option found in MYSQL_OPTS: '${opt}'" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(RUN): Blacklist pattern: '^${evil}'" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(HLP): Remove it. This option is handled by the tool itself." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			exit $EXIT_ABORT
		fi
	done
	for bad in ${MYSQL_BAD_OPTS}; do
		if echo "${opt}" | grep -e "^${bad}" > /dev/null 2>&1; then
			debug "fatal" "(CFG): Disallowed mysqldump option found in MYSQL_OPTS: '${opt}'" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(RUN): Blacklist pattern: '^${bad}'" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "(HLP): Remove it. This option can be controlled via the configuration file itself." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			exit $EXIT_ABORT
		fi
	done
done





############################################################
# Consistency/Transactions
############################################################

# CONSISTENT_DUMP_ONLY_INNODB
if ! set | grep '^CONSISTENT_DUMP_ONLY_INNODB=' >/dev/null 2>&1; then
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_ONLY_INNODB variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_ONLY_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${CONSISTENT_DUMP_ONLY_INNODB}" ]; then
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_ONLY_INNODB variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_ONLY_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${CONSISTENT_DUMP_ONLY_INNODB}" = "1" ]; then
	debug "trace" "(CFG): InnoDB-only:  Dumping consistently across tables (using '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${CONSISTENT_DUMP_ONLY_INNODB}" = "0" ]; then
	debug "trace" "(CFG): InnoDB-only:  Not dumping consistently across tables (using '--skip-lock-tables') [unsafe]" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_ONLY_INNODB variable has an invalid value: ${CONSISTENT_DUMP_ONLY_INNODB}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--single-transaction')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_ONLY_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# CONSISTENT_DUMP_NO_INNODB
if ! set | grep '^CONSISTENT_DUMP_NO_INNODB=' >/dev/null 2>&1; then
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_NO_INNODB variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_NO_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${CONSISTENT_DUMP_NO_INNODB}" ]; then
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_NO_INNODB variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_NO_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${CONSISTENT_DUMP_NO_INNODB}" = "1" ]; then
	debug "trace" "(CFG): InnoDB-none:  Dumping consistently across tables (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${CONSISTENT_DUMP_NO_INNODB}" = "0" ]; then
	debug "trace" "(CFG): InnoDB-none:  Not dumping consistently across tables (using '--skip-lock-tables') [unsafe]" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_NO_INNODB variable has an invalid value: ${CONSISTENT_DUMP_NO_INNODB}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_NO_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

# CONSISTENT_DUMP_MIXED_INNODB
if ! set | grep '^CONSISTENT_DUMP_MIXED_INNODB=' >/dev/null 2>&1; then
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_MIXED_INNODB variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_MIXED_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${CONSISTENT_DUMP_MIXED_INNODB}" ]; then
	debug "warn" "(CFG): \$CONSISTENT_DUMP_MIXED_INNODB variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_MIXED_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${CONSISTENT_DUMP_MIXED_INNODB}" = "1" ]; then
	debug "trace" "(CFG): InnoDB-mixed: Dumping consistently across tables (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${CONSISTENT_DUMP_MIXED_INNODB}" = "2" ]; then
	debug "trace" "(CFG): InnoDB-mixed: Dumping consistently across tables (using '--single-transaction') [unsafe]" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${CONSISTENT_DUMP_MIXED_INNODB}" = "0" ]; then
	debug "trace" "(CFG): InnoDB-mixed: Not dumping consistently across tables (using '--skip-lock-tables') [unsafe]" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn"  "(CFG): \$CONSISTENT_DUMP_MIXED_INNODB variable has an invalid value: ${CONSISTENT_DUMP_MIXED_INNODB}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn"  "(RUN): Setting default to: 1 (using '--lock-tables')" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	CONSISTENT_DUMP_MIXED_INNODB="1"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi




############################################################
# IGNORE/REQUIRE
############################################################

# Ignored databases
if ! set | grep '^IGNORE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$IGNORE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
	debug "warn" "(HLP): Define \$IGNORE in your config to get rid of this warning" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): No database will be ignored" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	IGNORE=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${IGNORE}" ]; then
	debug "trace" "(CFG): \$IGNORE variable is empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "trace" "(RUN): No database will be ignored" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	IGNORE=""
else
	debug "trace" "(CFG): Ignored DB's: ${IGNORE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi

# Required databases
if ! set | grep '^REQUIRE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$REQUIRE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(HLP): Define \$REQUIRE in your config to get rid of this warning" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(RUN): No database will be required" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	REQUIRE=""
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${REQUIRE}" ]; then
	debug "trace" "(CFG): \$REQUIRE variable is empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "trace" "(RUN): No database will explicitly be required" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	REQUIRE=""
else
	debug "trace" "(CFG): Required DB's: ${REQUIRE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi





############################################################
# Compression
############################################################
# Check $COMPRESS
if ! set | grep '^COMPRESS=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$COMPRESS variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${COMPRESS}" ]; then
	debug "warn" "(CFG): \$COMPRESS variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${COMPRESS}" = "1" ]; then

	# COMPRESS_BIN
	if ! set | grep '^COMPRESS_BIN=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$COMPRESS_BIN variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		COMPRESS=0
		COMPRESS_BIN=""
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${COMPRESS_BIN}" ]; then
		debug "warn" "(CFG): \$COMPRESS_BIN variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		COMPRESS=0
		COMPRESS_BIN=""
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		# Does COMPRESS_BIN binary exist?
		if ! command -v "${COMPRESS_BIN}" > /dev/null 2>&1 ; then
			debug "err" "(CFG): ${COMPRESS_BIN} not found. Fix \$COMPRESS_BIN" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(HLP): Fix \$COMPRESS_BIN" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		fi
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		# COMPRESS_ARG
		if ! set | grep '^COMPRESS_ARG=' >/dev/null 2>&1; then
			debug "warn" "(CFG): \$COMPRESS_ARG variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Using no command line arguments for ${COMPRESS_BIN}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS_ARG=""
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		# Can be empty
		elif [ -z "${COMPRESS_ARG}" ]; then
			debug "trace" "(CFG): No compression arguments specified for ${COMPRESS_BIN}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		# COMPRESS_ARG
		if ! set | grep '^COMPRESS_EXT=' >/dev/null 2>&1; then
			debug "warn" "(CFG): \$COMPRESS_EXT variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Using 'compressed' as file extension." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS_EXT="compressed"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif [ -z "${COMPRESS_EXT}" ]; then
			debug "warn" "(CFG): \$COMPRESS_EXT variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Using 'compressed' as file extension." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			COMPRESS_EXT="compressed"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		fi
	fi

	# If compression is still enabled
	if [ "${COMPRESS}" = "1" ]; then
		debug "info"  "(OPT): Compression enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "debug" "(OPT): Compression arguments: ${COMPRESS_BIN} ${COMPRESS_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi

elif [ "${COMPRESS}" = "0" ]; then
	debug "info" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn" "(CFG): Invalid value for \$COMPRESS: ${COMPRESS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Compression disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	COMPRESS=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi



############################################################
# Encryption
############################################################
if ! set | grep '^ENCRYPT=' >/dev/null 2>&1; then
	debug "fatal" "(CFG): \$ENCRYPT variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow encrypted dumps." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ -z "${ENCRYPT}" ]; then
	debug "fatal" "(CFG): \$ENCRYPT variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow encrypted dumps." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
elif [ "${ENCRYPT}" = "1" ]; then

	# OPENSSL_PUBKEY_PEM
	if ! set | grep '^OPENSSL_PUBKEY_PEM=' >/dev/null 2>&1; then
		debug "fatal" "(CFG): \$OPENSSL_PUBKEY_PEM variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	elif [ -z "${OPENSSL_PUBKEY_PEM}" ]; then
		debug "fatal" "(CFG): \$OPENSSL_PUBKEY_PEM variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	elif [ ! -f "${OPENSSL_PUBKEY_PEM}" ]; then
		debug "fatal"  "(RUN): OpenSSL pubkey not found in ${OPENSSL_PUBKEY_PEM}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal"  "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	elif [ ! -r "${OPENSSL_PUBKEY_PEM}" ]; then
		debug "fatal" "(RUN): OpenSSL pubkey not readable" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi

	# OpenSSL Algorithm argument
	if ! set | grep '^OPENSSL_ALGO_ARG=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$OPENSSL_ALGO_ARG variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(RUN): Encryption defaults to: ${_DEFAULT_OPENSSL_ALGO_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		OPENSSL_ALGO_ARG="${_DEFAULT_OPENSSL_ALGO_ARG}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${OPENSSL_ALGO_ARG}" ]; then
		debug "warn" "(CFG): \$OPENSSL_ALGO_ARG variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(RUN): Encryption defaults to: ${_DEFAULT_OPENSSL_ALGO_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		OPENSSL_ALGO_ARG="${_DEFAULT_OPENSSL_ALGO_ARG}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	fi

	# Test OpenSSL
	if ! command -v openssl > /dev/null 2>&1 ; then
		debug "fatal" "(RUN): 'openssl' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi
	if ! echo "test" | $(which openssl) smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} "${OPENSSL_PUBKEY_PEM}" > /dev/null 2>&1 ; then
		debug "fatal" "(RUN): openssl encryption test failed. Validate \$OPENSSL_ALGO_ARG" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi

	debug "info"  "(OPT): Encryption enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "debug" "(OPT): Encryption algorithm: ${OPENSSL_ALGO_ARG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "debug" "(OPT): Encryption pub key: ${OPENSSL_PUBKEY_PEM}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

elif [ "${ENCRYPT}" = "0" ]; then
	debug "info" "(OPT): Encryption disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	ENCRYPT="0"
else
	debug "fatal" "(CFG): Invalid value for \$ENCRYPT: ${ENCRYPT}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "(HLP): It is not clear whether or not you only allow encrypted dumps." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi



############################################################
# Deletion
############################################################

if ! set | grep '^DELETE=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DELETE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DELETE=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DELETE}" ]; then
	debug "warn" "(CFG): \$DELETE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DELETE=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${DELETE}" = "1"  ]; then

	# DELETE_METHOD
	if ! set | grep '^DELETE_METHOD=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$DELETE_METHOD variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DELETE=0
		DELETE_METHOD=""
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${DELETE_METHOD}" ]; then
		debug "warn" "(CFG): \$DELETE_METHOD variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DELETE=0
		DELETE_METHOD=""
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ "${DELETE_METHOD}" = "tmpwatch" ] && ! command -v tmpwatch > /dev/null 2>&1 ; then
		debug "err"  "(RUN): 'tmpwatch' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"  "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DELETE=0
		DELETE_METHOD=""
		MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
	elif [ "${DELETE_METHOD}" = "tmpreaper" ] && ! command -v tmpreaper > /dev/null 2>&1 ; then
		debug "err"  "(RUN): 'tmpreaper' not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"  "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DELETE=0
		DELETE_METHOD=""
		MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
	elif [ "${DELETE_METHOD}" != "tmpwatch" ] && [ "${DELETE_METHOD}" != 'tmpreaper' ]; then
		debug "err"  "(CFG): \$DELETE_METHOD must be either 'tmpwatch' or 'tmpreaper' in ${CONFIG_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"  "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		DELETE=0
		DELETE_METHOD=""
		MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
	else

		# DELETE_IF_OLDER
		if ! set | grep '^DELETE_IF_OLDER=' >/dev/null 2>&1; then
			debug "warn" "(CFG): \$DELETE_IF_OLDER variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif [ -z "${DELETE_IF_OLDER}" ]; then
			debug "warn" "(CFG): \$DELETE_IF_OLDER variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif ! valid_tmpwatch "${DELETE_IF_OLDER}" > /dev/null 2>&1 ; then
			debug "err"  "(CFG): \$DELETE_IF_OLDER does not have a valid ${DELETE_METHOD} value: ${DELETE_IF_OLDER}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err"  "(HLP): See: man ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err"  "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		fi
	fi

	# If deletion is still enabled
	if [ "${DELETE}" = "1"  ]; then

		debug "info"  "(OPT): Deletion enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "debug" "(OPT): Deleting files older than $(get_tmpwatch_value "${DELETE_IF_OLDER}") $(get_tmpwatch_unit_name "${DELETE_IF_OLDER}"). Using: ${DELETE_METHOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

		# DELETE_FORCE
		if ! set | grep '^DELETE_FORCE=' >/dev/null 2>&1; then
			debug "warn" "(CFG): \$DELETE_FORCE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE_FORCE=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif [ -z "${DELETE_FORCE}" ]; then
			debug "warn" "(CFG): \$DELETE_FORCE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(RUN): Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE_FORCE=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif [ "${DELETE_FORCE}" = "1"  ]; then
			debug "trace" "(CFG): ${DELETE_METHOD}: Using '--force' option (deleting read-only files)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		elif [ "${DELETE_FORCE}" = "0"  ]; then
			debug "trace" "(CFG): ${DELETE_METHOD}: Not forcing (--force) deletion for read-only files" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		else
			debug "err" "(CFG): Invalid value for \$DELETE_FORCE: ${DELETE_FORCE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "err" "(RUN): Setting \$DELETE_FORCE = 0" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			DELETE_FORCE=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		fi
	fi

elif [ "${DELETE}" = "0"  ]; then
	debug "info" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err" "(CFG): Invalid value for \$DELETE: ${DELETE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err" "(OPT): Deletion disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DELETE=0
	MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
fi





############################################################
# Nagios
############################################################
# NAGIOS_LOG
if ! set | grep '^NAGIOS_LOG=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$NAGIOS_LOG variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	NAGIOS_LOG=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${NAGIOS_LOG}" ]; then
	debug "warn" "(CFG): \$NAGIOS_LOG variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	NAGIOS_LOG=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${NAGIOS_LOG}" = "1"  ]; then

	# NAGIOS_LOG_CHMOD
	if ! set | grep '^NAGIOS_LOG_CHMOD=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$NAGIOS_LOG_CHMOD variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(RUN): Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${NAGIOS_LOG_CHMOD}" ]; then
		debug "warn" "(CFG): \$NAGIOS_LOG_CHMOD variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(RUN): Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif ! valid_chmod "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1; then
		debug "err"  "(CFG): Invalid chmod value for \$NAGIOS_LOG_CHMOD: ${NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "err"  "(RUN): Setting default to ${_DEFAULT_NAGIOS_LOG_CHMOD}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		NAGIOS_LOG_CHMOD="${_DEFAULT_NAGIOS_LOG_CHMOD}"
		MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
	fi

	# NAGIOS_LOGFILE
	if ! set | grep '^NAGIOS_LOGFILE=' >/dev/null 2>&1; then
		debug "warn" "(CFG): \$NAGIOS_LOGFILE variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		NAGIOS_LOG=0
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ -z "${NAGIOS_LOGFILE}" ]; then
		debug "warn" "(CFG): \$NAGIOS_LOGFILE variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		NAGIOS_LOG=0
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	elif [ ! -f "${NAGIOS_LOGFILE}" ]; then
		debug  "warn" "(RUN): ${NAGIOS_LOGFILE} not found" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugi "warn" "(RUN): Trying to create..." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

		if ! touch "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err" "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "err" "(RUN): Failed to create file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "err" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			NAGIOS_LOG=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		else
			debugn "warn" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "warn" "(RUN): Created file ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debugi "warn" "(RUN): Trying to chmod to ${NAGIOS_LOG_CHMOD}..." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

			if ! chmod ${NAGIOS_LOG_CHMOD} "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
				debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(RUN): Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "err"  "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				NAGIOS_LOG=0
				MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
			else
				debugn "warn" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			fi
		fi
	# Check if it has wrong permissions
	elif ! compare_chmod "$(get_file_chmod "${NAGIOS_LOGFILE}")" "${NAGIOS_LOG_CHMOD}" > /dev/null 2>&1 ; then
		debug  "warn" "(RUN): Nagios logfile has wrong permissions: $(get_file_chmod "${NAGIOS_LOGFILE}"), but should be: ${NAGIOS_LOG_CHMOD} " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugi "warn" "(RUN): Trying to chmod to ${NAGIOS_LOG_CHMOD}... " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))

		if ! chmod "${NAGIOS_LOG_CHMOD}" "${NAGIOS_LOGFILE}" > /dev/null 2>&1 ; then
			debugn "err"  "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "err"  "(RUN): Failed to chmod ${NAGIOS_LOG_CHMOD} ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug  "err"  "(OPT): Nagios plugin log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			NAGIOS_LOG=0
			MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		else
			debugn "warn" "OK" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi
	fi

	# Still enabled?
	if [ "${NAGIOS_LOG}" = "1"  ]; then
		if [ ! -r "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "(RUN): ${NAGIOS_LOGFILE} not readable" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(HLP): FIX \NAGIOS_LOG_CHMOD value in config" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			NAGIOS_LOG=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		elif [ ! -w "${NAGIOS_LOGFILE}" ]; then
			debug "warn" "(RUN): ${NAGIOS_LOGFILE} not writeable" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(HLP): FIX \NAGIOS_LOG_CHMOD value in config" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "warn" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			NAGIOS_LOG=0
			MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		else
			debug "info"  "(OPT): Nagios log enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			debug "debug" "(OPT): Nagios logfile: ${NAGIOS_LOGFILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi
	fi

elif [ "${NAGIOS_LOG}" = "0"  ]; then
	debug "info" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "err" "(CFG): Invalid value for \$NAGIOS_LOG: ${NAGIOS_LOG}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "err" "(OPT): Nagios log disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DELETE=0
	MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
fi




############################################################
# Info file
############################################################

if ! set | grep '^DUMP_FILE_INFO=' >/dev/null 2>&1; then
	debug "warn" "(CFG): \$DUMP_FILE_INFO variable is not defined" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Info files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_INFO=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ -z "${DUMP_FILE_INFO}" ]; then
	debug "warn" "(CFG): \$DUMP_FILE_INFO variable should not be empty" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Info files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_INFO=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
elif [ "${DUMP_FILE_INFO}" = "1"  ]; then
	debug "info" "(OPT): Info files enabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
elif [ "${DUMP_FILE_INFO}" = "0"  ]; then
	debug "info" "(OPT): Info files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "warn" "(CFG): Invalid value for \$DUMP_FILE_INFO: ${DUMP_FILE_INFO}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "warn" "(OPT): Info files disabled" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	DUMP_FILE_INFO=0
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi






############################################################
# Connection
############################################################


# Testing MySQL Connection
if ! _CONN_ERR="$( mysql_test_connection "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" )"; then
	debug  "fatal" "(RUN): Cannot connect to mysql database." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugr "fatal" "(RUN): Via: $(which mysql) --defaults-file=${MYSQL_CNF_FILE} ${MYSQL_SSL_ARGS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugr "fatal" "(RUN): SQL: ${_CONN_ERR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debugr "fatal" "(HLP): Fix credentials in: ${MYSQL_CNF_FILE}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug  "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
else
	debug "trace" "(RUN): MySQL connection test successful." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi


# Getting MySQL Server Status
if ! MYSQL_SERVER_STATUS="$( get_mysql_server_status "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" )"; then
	debug "fatal" "(SRV): Cannot retrieve MySQL server status" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi


# MySQL TCP/IP or Socket connection
debug "debug"  "(SRV): MySQL server connection: $( get_mysql_connection_type_info "${MYSQL_SERVER_STATUS}" )" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


# Testing MySQL for SSL connection
MYSQL_SSL_STATUS="$( get_mysql_connection_ssl_info "${MYSQL_SERVER_STATUS}" )"
if [ "${MYSQL_SSL_STATUS}" = "Not in use" ]; then
	if [ "${MYSQL_SSL_ENABLE}" = "1" ]; then
		debug "fatal" "(SRV): MySQL server connection: Not using SSL, but demanded." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "(HLP): We have already made some plain-text connections" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "(HLP): It is advised to change your password immediately" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	else
		debug "debug"  "(SRV): MySQL server connection: Not using SSL (plain)." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
else
	debug "debug" "(SRV): MySQL server connection: Using SSL (${MYSQL_SSL_STATUS})" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi

# Testing MySQL for Master or Slave
if ! MYSQL_SERVER_TYPE="$(get_mysql_server_replication_type "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}")"; then
	debug "fatal" "(RUN): Connection error" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
else
	debug "debug" "(SRV): MySQL server rep type:   ${MYSQL_SERVER_TYPE}"  $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
fi


# Get MySQL Name and Version
MYSQL_SERVER="$( get_mysql_server_name "${MYSQL_SERVER_STATUS}" )"
MYSQL_VERSION="$( get_mysql_server_version "${MYSQL_SERVER_STATUS}" )"

# Get MySQL Server Hostname and Port
MYSQL_HOST="$( get_mysql_server_hostname "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" )"
MYSQL_PORT="$( get_mysql_server_port "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" )"

debug "debug" "(SRV): MySQL server version:    $( [ "${MYSQL_SERVER}" != "" ] && echo "${MYSQL_SERVER} " )${MYSQL_VERSION}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
debug "debug" "(SRV): MySQL server hostname:   ${MYSQL_HOST}:${MYSQL_PORT}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"











############################################################
# Test mode
############################################################
if [ "${_ARG_TEST}" = "1" ]; then
	debug "info" "Exiting program from test mode (--test)."  ${LOG} "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_OK
fi


################################################################################
#
# ENTRY POINT: MAIN
#
################################################################################

# Binaries
#MYSQL="$(which mysql 2>/dev/null)"
MYSQLDUMP="$(which mysqldump 2>/dev/null)"
OPENSSL="$(which openssl 2>/dev/null)"
TMPWATCH="$(which "${DELETE_METHOD}" 2>/dev/null)"	# This can be tmpwatch or tmpreaper
MKTEMP="$(which mktemp 2>/dev/null)"

# Error code for nagios
ERROR=0



############################################################
# Create tmp files and folders
############################################################

# New temporary directory
if MY_TMP_DIR="$( ${MKTEMP} -d ${TMP_DIR}/mysqldump-secure.XXXXXXXXXX 2>/dev/null)"; then
	debug "trace"  "(RUN): Creating tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "fatal" "(RUN): Cannot create tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Temp file 'mysqldump'
if MY_TMP_FILE_DUMP="$( ${MKTEMP} "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "trace"  "(RUN): Creating tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "fatal" "(RUN): Cannot create tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Temp file 'compression'
if MY_TMP_FILE_COMP="$( ${MKTEMP} "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "trace"  "(RUN): Creating tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "fatal" "(RUN): Cannot create tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

# Temp file 'encryption'
if MY_TMP_FILE_ENCR="$( ${MKTEMP} "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
	debug "trace"  "(RUN): Creating tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
else
	debug "fatal" "(RUN): Cannot create tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug "fatal" "Aborting" $LOG "" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_ABORT
fi

if [ "${DELETE}" = "1" ]; then
	# Temp file 'tmpwatch/tmpreaper'
	if MY_TMP_FILE_DEL="$( ${MKTEMP} "${MY_TMP_DIR}/.XXXXXXXXXXXXXXX" 2>/dev/null)"; then
		debug "trace"  "(RUN): Creating tmp file: ${MY_TMP_FILE_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	else
		debug "fatal" "(RUN): Cannot create tmp file: ${MY_TMP_FILE_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debug "fatal" "Aborting" $LOG "" "${_ARG_CRON}" "${_ARG_VERB}"
		exit $EXIT_ABORT
	fi
fi


############################################################
# Get all databases
############################################################

# Get a list of all databases
debugi "debug" "(SQL): Retrieving list of databases... " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

# Get all databases
DATABASES="$( get_mysql_databases "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" )"
NUM_DB="$( get_mysql_database_count "${DATABASES}" )"

debugn "debug" "${NUM_DB}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


############################################################
# Dump databases
############################################################

TOTAL_STARTTIME=$(date +%s)
TOTAL_SIZE=0
TOTAL_DBS=0
TOTAL_IGN=0
TOTAL_ERR=0

# Get info for nagios log
NAGIOS_DB_DUMPED=""
NAGIOS_DB_IGNORED=""
NAGIOS_DB_ERROR=""


# Lopp counter
i=0

for db in ${DATABASES}; do


	# Increment Loop counter
	i=$((i + 1))



	# Show progress
	# At which database are we right now?
	# Left-space-padded " 1/10" counter
	_cnt="$(printf "%$(str_len "${NUM_DB}")d/%d" "${i}" "${NUM_DB}")"


	# SKIPPING DATABASES
	skip_empty=0
	skip_ignored=0

	# Empty databases
	if mysql_database_is_empty "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" "${db}"; then
		skip_empty=1
	fi

	# Ignored database
	if _ignore_pattern="$( database_is_ignored "${IGNORE}" "${db}" )"; then
		skip_ignored=1
		debug "trace" "(CFG): ${_cnt} Ignoring DB: \"${db}\" by wildcard: \"${_ignore_pattern}\""  $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

		# Only if ignored database is not required, we can ignore it.
		if database_is_required "${REQUIRE}" "${db}"; then
			skip_ignored=0
			debug "trace" "(CFG): ${_cnt} Required DB: \"${db}\" un-ignored as it was found in \$REQUIRE"  $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi
	fi


	#
	# Main case 1 (skipping)
	#
	if [ "${skip_empty}" = "1" ] || [ "${skip_ignored}" = "1" ]; then


		# Empty AND Ignored
		if [ "${skip_empty}" = "1" ] && [ "${skip_ignored}" = "1" ]; then
			debug "info" "(SQL): ${_cnt} Skipping: ${db} (DB is empty and ignored)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		# Empty
		elif [ "${skip_empty}" = "1" ]; then
			debug "info" "(SQL): ${_cnt} Skipping: ${db} (DB is empty)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		# Ignored
		else
			debug "info" "(SQL): ${_cnt} Skipping: ${db} (DB is ignored)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		fi

		TOTAL_IGN=$((TOTAL_IGN + 1))
		[ "${NAGIOS_DB_IGNORED}" = "" ] && NAGIOS_DB_IGNORED="${db}" || NAGIOS_DB_IGNORED="${NAGIOS_DB_IGNORED},${db}"


	#
	# Main case 2 (dumping)
	#
	else

		# Determine which file extension to use (.sql, .sql.gz, .sql.gz.enc or .sql.enc)
		ext="$( build_file_extension "${ENCRYPT}" "${COMPRESS}" "${COMPRESS_EXT}" )"


		# File already exists on disk?
		if [ -f "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" ]; then

			# Increment total dbs error count
			TOTAL_ERR=$((TOTAL_ERR + 1))

			# Add failed db to nagios log
			[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"

			debug "err" "(RUN): ${_cnt} Failed:   ${db} cannot be written to disk (file exists: ${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext})" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
			ERROR="$(merge_exit_codes "${ERROR}" 2)"
			MDS_FAIL_COUNT=$((MDS_FAIL_COUNT + 1))

		# All Good, file can be written
		else



			#
			# TABLE ENGINES
			#
			_TABLES_INNODB=""
			_TABLES_OTHER=""
			MYSQL_LOCK_OPTS="--skip-lock-tables"


			# Get all table names and engines separated with '#'.
			# E.g: "test_table#InnoDB"
			TBL_ENGINES="$( get_mysql_database_table_names_and_engines "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" "${db}" "=" )"
			IFS='
			'

			# Assign Dump options to table engines.
			for _line in ${TBL_ENGINES}; do
				_table="$(echo "${_line}" | awk -F '=' '{print $1}')"
				_engine="$(echo "${_line}" | awk -F '=' '{print $2}')"

				if [ "${_engine}" = "InnoDB" ]; then
					[ -z "${_TABLES_INNODB}" ] && _TABLES_INNODB="${_table}" || _TABLES_INNODB="$( printf "%s %s" "${_TABLES_INNODB}" "${_table}")"
				else
					[ -z "${_TABLES_OTHER}"  ] && _TABLES_OTHER="${_table}"  || _TABLES_OTHER="$( printf "%s %s" "${_TABLES_OTHER}" "${_table}")"
				fi
			done
			unset IFS


			# information_schema and performance schema are special tables, which do not allow locking
			if [ "${db}" != "information_schema" ] && [ "${db}" != "performance_schema" ]; then

				# Apply consistency to InnoDB
				if [ "${CONSISTENT_DUMP_ONLY_INNODB}" = "1" ] && [ "${_TABLES_OTHER}" = "" ]; then
					debug "trace" "(RUN): ${_cnt} All tables use InnoDB. Dumping with --single-transaction" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--single-transaction"
				elif [ "${CONSISTENT_DUMP_NO_INNODB}" = "1" ] && [ "${_TABLES_INNODB}" = "" ]; then
					debug "trace" "(RUN): ${_cnt} No tables use InnoDB. Dumping with --lock-tables" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					debug "trace" "(RUN): ${_cnt} Non InnoDB tables: ${_TABLES_OTHER}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--lock-tables"
				elif [ "${CONSISTENT_DUMP_MIXED_INNODB}" = "1" ] && [ "${_TABLES_INNODB}" != "" ] && [ "${_TABLES_OTHER}" != "" ]; then
					debug "trace" "(RUN): ${_cnt} Some tables don't use InnoDB. Dumping with --lock-tables" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					debug "trace" "(RUN): ${_cnt} Non InnoDB tables: ${_TABLES_OTHER}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--lock-tables"
				elif [ "${CONSISTENT_DUMP_MIXED_INNODB}" = "2" ] && [ "${_TABLES_INNODB}" != "" ] && [ "${_TABLES_OTHER}" != "" ]; then
					debug "trace" "(RUN): ${_cnt} Some tables don't use InnoDB. Dumping with --single-transaction" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					debug "trace" "(RUN): ${_cnt} Non InnoDB tables: ${_TABLES_OTHER}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--single-transaction"
				else
					debug "trace" "(RUN): ${_cnt} \"${db}\": Not dumping consistently with '--lock-tables' or '--single-transaction'." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					debug "trace" "(RUN): ${_cnt} Non InnoDB tables: ${_TABLES_OTHER}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
					MYSQL_LOCK_OPTS="--skip-lock-tables"
				fi

			else
				debug "trace" "(RUN): ${_cnt} \"${db}\" is special and needs '--skip-lock-tables'" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
				MYSQL_LOCK_OPTS="--skip-lock-tables"
			fi




			#
			# VIRTUAL DATABASES
			#
			MYSQL_SPECIAL_OPTS=""

			# Performance schema does not allow to dump events
			# mysqldump: mysqldump  Couldn't execute 'show events'  Access denied for user 'root'@'localhost' to database 'performance_schema' (1044)
			if [ "${db}" = "performance_schema" ]; then
				debug "trace" "(RUN): ${_cnt} \"${db}\" cannot be dumped with --events. Adding --skip-events" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
				MYSQL_SPECIAL_OPTS="--skip-events"
			fi


			#
			# DATABASE SIZE
			#
			DB_SIZE_B="$( get_mysql_database_size "${MYSQL_CNF_FILE}" "${MYSQL_SSL_ARGS}" "${db}" )"
			DB_SIZE_KB="$( div "${DB_SIZE_B}" "1024" )"
			DB_SIZE_MB="$( div "${DB_SIZE_KB}" "1024" )"
			DB_SIZE_MB="$( round "${DB_SIZE_MB}" "2" )"


			TOTAL_SIZE=$( sum "${TOTAL_SIZE}" "${DB_SIZE_MB}" )

			#
			# MYSQL --quick/--skip-quick OPTION
			#
			MYSQL_QUICK_OPT="$(echo "${DB_SIZE_MB} ${MYSQL_OPTS_QUICK_MIN_SIZE}" | awk '{print ($1 >= $2) ? "--quick" : "--skip-quick" }')"


			#
			# RESET pipefail VARIABLE
			#
			error_statuses=""


			#
			# TRACK TIME
			#
			starttime=$(date +%s)


			#
			# GO GO GO!
			#

			#
			# Build final MySQLDump arguments
			#
			MYSQL_ARGUMENTS="--defaults-file=${MYSQL_CNF_FILE} ${MYSQL_SSL_ARGS}"
			MYSQLDUMP_ARGUMENTS="${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} ${MYSQL_SPECIAL_OPTS} ${MYSQL_QUICK_OPT}"


			if [ "${COMPRESS}" = "1" ]; then

				debugi "info" "(SQL): ${_cnt} Dumping:  ${db} (${DB_SIZE_MB} MB) " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

				#
				# Case 1/4 Compressed & Encrypted
				#
				if [ "${ENCRYPT}" = "1" ]; then
					ext=".sql.${COMPRESS_EXT}.enc"

					#
					# TODO: sync debug output and actual commmand (maybe via eval), so that it is made suer
					#       we are doing what we are showing.

					debugni "debug"  "(compressed) (encrypted) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) " )$( [ "${MYSQL_SPECIAL_OPTS}" != "" ] && echo "(${MYSQL_SPECIAL_OPTS}}) ")(${MYSQL_QUICK_OPT}) " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					# Ignore ${COMPRESS_ARG} to be quoted
					# shellcheck disable=SC2086
					error_statuses="$( (
						(
							${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} ${MYSQL_SPECIAL_OPTS} ${MYSQL_QUICK_OPT} "${db}" 2> "${MY_TMP_FILE_DUMP}";
							echo "0:$?:$(head -n1 "${MY_TMP_FILE_DUMP}")" >&3;
						) |
						(
							${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}";
							echo "1:$?:$(head -n1 "${MY_TMP_FILE_COMP}")" >&3;
						) |
						(
							${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}";
							echo "2:$?:$(head -n1 "${MY_TMP_FILE_ENCR}")" >&3;
						)
					) 3>&1 >&4)"
					exec 4>&-
				#
				# Case 2/4 Compressed Only
				#
				else
					ext=".sql.${COMPRESS_EXT}"
					debugni "debug"  "(compressed) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) ")$( [ "${MYSQL_SPECIAL_OPTS}" != "" ] && echo "(${MYSQL_SPECIAL_OPTS}) ")(${MYSQL_QUICK_OPT}) " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")"

					# POSIX pipefail emulation
					exec 4>&1
					# Ignore ${COMPRESS_ARG} to be quoted
					# shellcheck disable=SC2086
					error_statuses="$( (
						(
							${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} ${MYSQL_SPECIAL_OPTS} ${MYSQL_QUICK_OPT} "${db}" 2> "${MY_TMP_FILE_DUMP}";
							echo "0:$?:$(head -n1 "${MY_TMP_FILE_DUMP}")" >&3;
						) |
						(
							${COMPRESS_BIN} ${COMPRESS_ARG} 2> "${MY_TMP_FILE_COMP}" > "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}";
							echo "1:$?:$(head -n1 "${MY_TMP_FILE_COMP}")" >&3;
						)
					) 3>&1 >&4)"
					exec 4>&-

				fi
			else
				#
				# Case 3/4 Encrypted Only
				#
				if [ "${ENCRYPT}" = "1" ]; then
					ext=".sql.enc"
					debugni "debug"  "(encrypted) $( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) ")$( [ "${MYSQL_SPECIAL_OPTS}" != "" ] && echo "(${MYSQL_SPECIAL_OPTS}) ")(${MYSQL_QUICK_OPT}) " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					# Ignore ${COMPRESS_ARG} to be quoted
					# shellcheck disable=SC2086
					error_statuses="$( (
						(
							${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} ${MYSQL_SPECIAL_OPTS} ${MYSQL_QUICK_OPT} "${db}" 2> "${MY_TMP_FILE_DUMP}";
							echo "0:$?:$(head -n1 "${MY_TMP_FILE_DUMP}")" >&3;
						) |
						(
							${OPENSSL} smime -encrypt -binary -text -outform DER ${OPENSSL_ALGO_ARG} -out "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "${OPENSSL_PUBKEY_PEM}" 2> "${MY_TMP_FILE_ENCR}";
							echo "2:$?:$(head -n1 "${MY_TMP_FILE_ENCR}")" >&3;
						)
					) 3>&1 >&4)"
					exec 4>&-
				#
				# Case 4/4 Plain
				#
				else
					ext=".sql"
					debugni "debug"  "$( [ "${MYSQL_LOCK_OPTS}" != "" ] && echo "(${MYSQL_LOCK_OPTS}) ")$( [ "${MYSQL_SPECIAL_OPTS}" != "" ] && echo "(${MYSQL_SPECIAL_OPTS}) ")(${MYSQL_QUICK_OPT}) " $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# POSIX pipefail emulation
					exec 4>&1
					# Ignore ${COMPRESS_ARG} to be quoted
					# shellcheck disable=SC2086
					error_statuses="$( (
						(
							${MYSQLDUMP} --defaults-file="${MYSQL_CNF_FILE}" ${MYSQL_SSL_ARGS} ${MYSQL_OPTS} ${MYSQL_LOCK_OPTS} ${MYSQL_SPECIAL_OPTS} ${MYSQL_QUICK_OPT} "${db}" 2> "${MY_TMP_FILE_DUMP}" > "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}";
							echo "0:$?:$(head -n1 "${MY_TMP_FILE_DUMP}")" >&3;
						)
					) 3>&1 >&4)"
					exec 4>&-
				fi
			fi


			#
			# Error Checking
			#
			# Inside $error_statuses we have the following information.
			# Note: Not all lines must be there (depends on enabled options)
			#
			# "0:<exit code>:<stderr msg>"   <--mysqldump
			# "1:<exit code>:<stderr msg>"   <--compression
			# "2:<exit code>:<stderr msg>"   <--openssl
			#
			# Cases:
			#  1. Error code == 0 and <stderr msg> empty      => OK
			#  2. Error code == 0 and <stderr msg> not empty  => Warning
			#  3. Error code != 0                             => Error
			MY_ERRORS=""
			MY_WARNINGS=""


			#
			# TODO: functionalize
			# pipefail_errors() {} <-- or so?
			#

			IFS='
			'
			for _err in ${error_statuses}; do
				_type="$( echo "${_err}" | awk -F ':' '{print $1}' )"
				_exit="$( echo "${_err}" | awk -F ':' '{print $2}' )"
				_msg="$(  echo "${_err}" | awk -F ':' '{for (i=3; i<NF; i++) printf $i " "; print $NF}' )"

				if [ "${_type}" = "0" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="mysqldump: ${_msg}" || MY_ERRORS="$( printf "%s\nmysqldump: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="mysqldump: ${_msg}" || MY_WARNINGS="$( printf "%s\nmysqldump: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				elif [ "${_type}" = "1" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="compression: ${_msg}" || MY_ERRORS="$( printf "%s\ncompression: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="compression: ${_msg}" || MY_WARNINGS="$( printf "%s\ncompression: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				elif [ "${_type}" = "2" ]; then
					if [ "${_exit}" != "0" ]; then
						[ -z "${MY_ERRORS}" ] && MY_ERRORS="encryption: ${_msg}" || MY_ERRORS="$( printf "%s\nencryption: %s" "${MY_ERRORS}" "${_msg}")"
					elif [ "${_msg}" != "" ]; then
						[ -z "${MY_WARNINGS}" ] && MY_WARNINGS="encryption: ${_msg}" || MY_WARNINGS="$( printf "%s\nencryption: %s" "${MY_WARNINGS}" "${_msg}")"
					fi
				fi
			done
			unset IFS


			#
			# Error Evaluation
			#
			if [ "${MY_ERRORS}" != "" ]; then
				TOTAL_ERR=$((TOTAL_ERR + 1))

				debugn  "fatal" "Failed" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				debug   "fatal" "(RUN): ${_cnt} Error dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

				if [ "${MY_WARNINGS}" != "" ]; then
					debugr "warn" "${MY_WARNINGS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
					MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
				fi

				debugr  "fatal"  "${MY_ERRORS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				MDS_FAIL_COUNT=$((MDS_FAIL_COUNT + 1))


				ERROR="$(merge_exit_codes "${ERROR}" 2)"
				[ "${NAGIOS_DB_ERROR}" = "" ] && NAGIOS_DB_ERROR="${db}" || NAGIOS_DB_ERROR="${NAGIOS_DB_ERROR},${db}"
			else
				TOTAL_DBS=$((TOTAL_DBS + 1))
				endtime=$(date +%s)

				debugn "ok"    "$((endtime - starttime)) sec ($(get_file_size "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "m") MB)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
				debug  "trace" "(RUN): ${_cnt} Dump File: ${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}"  $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


				[ "${NAGIOS_DB_DUMPED}" = "" ] && NAGIOS_DB_DUMPED="${db}" || NAGIOS_DB_DUMPED="${NAGIOS_DB_DUMPED},${db}"

				if [ "${MY_WARNINGS}" != "" ]; then
					debug  "warn" "(RUN): ${_cnt} Warning dumping ${db}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
					debugr "warn" "${MY_WARNINGS}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
					MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
				fi


				# If all was good, remove required db from list
				# REQUIRED DATABASES
				#
				for req in ${REQUIRE}; do
					# Required database found?
					# Remove from variable
					if [ "${db}" = "${req}" ]; then
						REQUIRE="$( echo "${REQUIRE}" | sed "s/${db}//" )"
					fi
				done



				#
				# Write file info?
				#
				if [ "${DUMP_FILE_INFO}" = "1" ]; then
					debug "trace" "(RUN): ${_cnt} Info File: ${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}.info" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

					mtime="$( get_file_mtime "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" )"
					mtime_h="$( formatted_timestamp "${mtime}" "%Y-%m-%d %H:%M:%S %Z [%z]" )"

					# Set umask prior writing
					umask "$(chmod_2_umask "${DUMP_FILE_CHMOD}")";

					# Create file
					{
						echo "; mysqldump-secure backup record";
						echo "; Do not alter this file!";
						echo "; Creation of this file can be turned off via config file.";
						echo;
						echo "[mysqldump-secure]";
						echo "version = ${INFO_VERSION}";
						echo "vdate   = ${INFO_DATE}";
						echo "config  = ${CONFIG_FILE}";
						echo;
						echo "[system]";
						echo "host = $( hostname )";
						echo "user = $( whoami )";
						echo;
						echo "[file]";
						echo "file_path  = ${DUMP_DIR}";
						echo "file_name  = ${DUMP_FILE_PRE}${db}${ext}";
						echo "file_size  = $( get_file_size "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "b" ) Bytes ($( get_file_size "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "m" ) MB)";
						echo "file_chmod = $( get_file_chmod "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" )";
						echo "file_owner = $( get_file_owner "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" )";
						echo "file_group = $( get_file_group "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" )";
						echo "file_mtime = ${mtime} (${mtime_h})";
						echo "file_md5   = $( get_file_hash "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "md5" )";
						echo "file_sha   = $( get_file_hash "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}" "sha256" )";
						echo;
						echo "[mysqldump]";
						echo "encrypted  = ${ENCRYPT}";
						echo "compressed = ${COMPRESS}";
						echo "mysqldump  = ${MYSQLDUMP_ARGUMENTS}";
						echo "duration   = $((endtime - starttime)) sec"
						echo;
						echo "[compression]";
						echo "bin = $(if [ "${COMPRESS}" = "1" ]; then echo "${COMPRESS_BIN}"; fi)";
						echo "arg = $(if [ "${COMPRESS}" = "1" ]; then echo "${COMPRESS_ARG}"; fi)";
						echo;
						echo "[encryption]";
						echo "aes_arg = $(if [ "${ENCRYPT}" = "1" ]; then echo "${OPENSSL_ALGO_ARG}"; fi)";
						echo "rsa_pem = $(if [ "${ENCRYPT}" = "1" ]; then echo "${OPENSSL_PUBKEY_PEM}"; fi)";
						echo;
						echo "[connection]";
						echo "protocol  = $( get_mysql_connection_type_info "${MYSQL_SERVER_STATUS}" )";
						echo "secured   = $(if [ "${MYSQL_SSL_ENABLE}" = "1" ]; then echo "SSL: ${MYSQL_SSL_STATUS}"; else echo "No SSL"; fi )";
						echo "arguments = ${MYSQL_ARGUMENTS}";
						echo;
						echo "[server]";
						echo "host    = ${MYSQL_HOST}";
						echo "port    = ${MYSQL_PORT}";
						echo "type    = ${MYSQL_SERVER_TYPE}";
						echo "version = $(if [ "${MYSQL_SERVER}" != "" ]; then echo "${MYSQL_SERVER} ";fi)${MYSQL_VERSION}";
						echo;
						echo "[database]";
						echo "db_name = ${db}";
						echo "db_size = ${DB_SIZE_B} Bytes (${DB_SIZE_MB} MB)";
						echo "tbl_cnt = $( echo "${TBL_ENGINES}" | grep -c '' )";
						echo;
						echo "[tables]";
						echo "${TBL_ENGINES}" | sed 's/=/ = /g';
						echo;
					} > "${DUMP_DIR}/${DUMP_FILE_PRE}${db}${ext}.info"
				fi

			fi

		fi

	fi

done
TOTAL_ENDTIME=$(date +%s)


for req in ${REQUIRE}; do
	debug "err" "(RUN): Required database: \"${req}\" has not been dumped." $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_FAIL_COUNT=$((MDS_FAIL_COUNT + 1))
	ERROR="$(merge_exit_codes "${ERROR}" 2)"
done


debug "debug" "(RUN): Dumping finished (OK: ${TOTAL_DBS} dbs, IGN: ${TOTAL_IGN} dbs, ERR: ${TOTAL_ERR}, TOTAL: ${NUM_DB})" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
debug "debug" "(RUN): Took $((TOTAL_ENDTIME - TOTAL_STARTTIME)) seconds" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
debug "debug" "(RUN): Total size dumped: ${TOTAL_SIZE} MB" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"





############################################################
# Delete old Files
############################################################
TMPWATCH_NUM_DEL="0"
TMPWATCH_NUM_IGN="0"


if [ "${DELETE}" = "1" ]; then

	# Force deletion?
	if [ "${DELETE_FORCE}" = "1" ]; then FORCE_ARG="--force"; else FORCE_ARG=""; fi

	# Verbosity
	if [ "${DELETE_METHOD}" = "tmpwatch" ]; then TMPWATCH_OPTS="-vv"; else TMPWATCH_OPTS="--verbose=3 --showdeleted"; fi


	TMPWATCH_RUN="$(${TMPWATCH} ${FORCE_ARG} -m "${DELETE_IF_OLDER}" "${TMPWATCH_OPTS}" "${DUMP_DIR}/" 2> "${MY_TMP_FILE_DEL}")"
	TMPWATCH_ERRNO="$?"
	TMPWATCH_ERROR="$( cat "${MY_TMP_FILE_DEL}" )"

	if [ "${TMPWATCH_ERRNO}" != "0" ]; then
		debug  "err"  "(RUN): ${DELETE_METHOD} exit code: ${TMPWATCH_ERRNO}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugr "err"  "(RUN): ${DELETE_METHOD} error: ${TMPWATCH_ERROR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_ERROR_COUNT=$((MDS_ERROR_COUNT + 1))
		ERROR="$(merge_exit_codes "${ERROR}" 1)"
	elif [ "${TMPWATCH_ERROR}" != "" ]; then
		debug  "warn" "(RUN): ${DELETE_METHOD} exit code: ${TMPWATCH_ERRNO}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugr "warn" "(RUN): ${DELETE_METHOD} error: ${TMPWATCH_ERROR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		ERROR="$(merge_exit_codes "${ERROR}" 1)"
	fi


	# Number removed/skipped files
	TMPWATCH_NUM_DEL="$( echo "${TMPWATCH_RUN}" | grep -ci 'Removing file' )"
	TMPWATCH_NUM_IGN="$( echo "${TMPWATCH_RUN}" | grep -ci 'skipped:' )"

	# Output of removed/skipped files
	TMPWATCH_TXT_DEL="$( echo "${TMPWATCH_RUN}" | grep -i 'Removing file' )"
	TMPWATCH_TXT_IGN="$( echo "${TMPWATCH_RUN}" | grep -i 'skipped:' )"


	# Number of deleted files and the command itself
	debug  "info"  "(RUN): Deleting files older than $(get_tmpwatch_value "${DELETE_IF_OLDER}") $(get_tmpwatch_unit_name "${DELETE_IF_OLDER}") ... ${TMPWATCH_NUM_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	debug  "trace" "${TMPWATCH} ${FORCE_ARG} -m ${DELETE_IF_OLDER} ${TMPWATCH_OPTS} ${DUMP_DIR}/" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"


	# Some files have been skipped!
	if [ "${TMPWATCH_NUM_IGN}" != "0" ] || [ "${TMPWATCH_TXT_IGN}" != "" ]; then
		debug  "warn" "(RUN): ${DELETE_METHOD}: ${TMPWATCH_NUM_IGN} files could not be deleted:" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		debugr "warn" "${TMPWATCH_TXT_IGN}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
		ERROR="$(merge_exit_codes "${ERROR}" 1)"
	fi

	# Show deleted files
	debugr "info" "${TMPWATCH_TXT_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

	# Show full trace output
	debugr "trace" "${TMPWATCH_RUN}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

fi



############################################################
# Nagios Plugin Log
############################################################
if [ "${NAGIOS_LOG}" = "1" ]; then
	debug "debug" "(RUN): Writing nagios logfile" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"

	{
		echo "[state]";
		echo "success = ${ERROR}";
		echo "lastbak = ${TOTAL_STARTTIME}";
		echo "message = ";
		echo "missing = ${REQUIRE}";
		echo;
		echo "[options]";
		echo "opt_log = ${LOG}";
		echo "opt_com = ${COMPRESS}";
		echo "opt_enc = ${ENCRYPT}";
		echo "opt_del = ${DELETE}";
		echo;
		echo "[messages]";
		echo "msg_dbs = ${TOTAL_DBS}";
		echo "msg_ign = ${TOTAL_IGN}";
		echo "msg_err = ${TOTAL_ERR}";
		echo "msg_meg = ${TOTAL_SIZE}";
		echo "msg_sec = $((TOTAL_ENDTIME - TOTAL_STARTTIME))";
		echo "msg_del = ${TMPWATCH_NUM_DEL}";
		echo;
		echo "[tmpwatch]";
	} > "${NAGIOS_LOGFILE}"

	if [ "${DELETE}" = "1" ]; then
		{
			echo "del_time = ${DELETE_IF_OLDER}";
			echo "del_del  = ${TMPWATCH_NUM_DEL}";	# how many files deleted
			echo "del_skp  = ${TMPWATCH_NUM_IGN}";	# how many files skipped (due to unable to delete)
		} >> "${NAGIOS_LOGFILE}"
	else
		{
			echo "del_time = 0";
			echo "del_del  = 0";	# how many files deleted
			echo "del_skp  = 0";	# how many files skipped (due to unable to delete)
		} >> "${NAGIOS_LOGFILE}"
	fi

	{
		echo;
		echo "[stats]";
		echo "db_dumped = ${NAGIOS_DB_DUMPED}";
		echo "db_error = ${NAGIOS_DB_ERROR}";
		echo "db_ignored = ${NAGIOS_DB_IGNORED}";
		echo;
		echo "[misc]";
		echo "version = ${INFO_VERSION}";	# mysqldump-secure version (for checking against latest)
	} >> "${NAGIOS_LOGFILE}"

fi




############################################################
# Delete temporary files
############################################################

#
# Delete tmp files/folders in reverse order
#

if [ "${DELETE}" = "1" ]; then
	if rm "${MY_TMP_FILE_DEL}" 2>/dev/null; then
		debug "trace" "(RUN): Deleting tmp file: ${MY_TMP_FILE_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
	else
		debug "warn"  "(RUN): Cannot delete tmp file: ${MY_TMP_FILE_DEL}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
		MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
	fi
fi

if rm "${MY_TMP_FILE_DUMP}" 2>/dev/null; then
	debug "trace" "(RUN): Deleting tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
else
	debug "warn"  "(RUN): Cannot delete tmp file: ${MY_TMP_FILE_DUMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

if rm "${MY_TMP_FILE_COMP}" 2>/dev/null; then
	debug "trace" "(RUN): Deleting tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
else
	debug "warn"  "(RUN): Cannot delete tmp file: ${MY_TMP_FILE_COMP}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

if rm "${MY_TMP_FILE_ENCR}" 2>/dev/null; then
	debug "trace" "(RUN): Deleting tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
else
	debug "warn"  "(RUN): Cannot delete tmp file: ${MY_TMP_FILE_ENCR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi

if rm -rf "${MY_TMP_DIR}" 2>/dev/null; then
	debug "trace" "(RUN): Deleting tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}" "${_ARG_VERB}"
else
	debug "warn"  "(RUN): Cannot delete tmp dir:  ${MY_TMP_DIR}" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	MDS_WARNING_COUNT=$((MDS_WARNING_COUNT + 1))
fi



############################################################
# Exit
############################################################

if [ "${MDS_FAIL_COUNT}" != "0" ]; then
	if [ "${MDS_FAIL_COUNT}" = "1" ]; then
		debug "fatal" "Finished with ${MDS_FAIL_COUNT} failed backup" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	else
		debug "fatal" "Finished with ${MDS_FAIL_COUNT} failed backups" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
	exit $EXIT_FAIL
elif [ "${MDS_ERROR_COUNT}" != "0" ]; then
	if [ "${MDS_ERROR_COUNT}" = "1" ]; then
		debug "err"  "Finished with ${MDS_ERROR_COUNT} error. (Backups done successfully)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	else
		debug "err"  "Finished with ${MDS_ERROR_COUNT} errors. (Backups done successfully)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
	exit $EXIT_ERROR
elif [ "${MDS_WARNING_COUNT}" != "0" ]; then
	if [ "${MDS_WARNING_COUNT}" = "1" ]; then
		debug "warn"  "Finished with ${MDS_WARNING_COUNT} warning. (Backups done successfully)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	else
		debug "warn"  "Finished with ${MDS_WARNING_COUNT} warnings. (Backups done successfully)" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	fi
	exit $EXIT_WARNING
else
	debug "ok" "Finished successfully" $LOG "${LOGFILE}" "${_ARG_CRON}" "${_ARG_VERB}"
	exit $EXIT_OK
fi
